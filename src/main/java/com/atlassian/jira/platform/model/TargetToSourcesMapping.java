/*
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT-1461af1efd5cc75bf21cb8256a8b42f9bd4278be
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.platform.model;

import java.util.Objects;
import com.atlassian.jira.platform.model.TargetClassification;
import com.atlassian.jira.platform.model.TargetMandatoryFields;
import com.atlassian.jira.platform.model.TargetStatus;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.invoker.JSON;

/**
 * An object representing the mapping of issues and data related to destination entities, like fields and statuses, that are required during a bulk move.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-04T17:36:18.838627-04:00[America/New_York]", comments = "Generator version: 7.12.0")
public class TargetToSourcesMapping {
  public static final String SERIALIZED_NAME_INFER_CLASSIFICATION_DEFAULTS = "inferClassificationDefaults";
  @SerializedName(SERIALIZED_NAME_INFER_CLASSIFICATION_DEFAULTS)
  @javax.annotation.Nonnull
  private Boolean inferClassificationDefaults;

  public static final String SERIALIZED_NAME_INFER_FIELD_DEFAULTS = "inferFieldDefaults";
  @SerializedName(SERIALIZED_NAME_INFER_FIELD_DEFAULTS)
  @javax.annotation.Nonnull
  private Boolean inferFieldDefaults;

  public static final String SERIALIZED_NAME_INFER_STATUS_DEFAULTS = "inferStatusDefaults";
  @SerializedName(SERIALIZED_NAME_INFER_STATUS_DEFAULTS)
  @javax.annotation.Nonnull
  private Boolean inferStatusDefaults;

  public static final String SERIALIZED_NAME_INFER_SUBTASK_TYPE_DEFAULT = "inferSubtaskTypeDefault";
  @SerializedName(SERIALIZED_NAME_INFER_SUBTASK_TYPE_DEFAULT)
  @javax.annotation.Nonnull
  private Boolean inferSubtaskTypeDefault;

  public static final String SERIALIZED_NAME_ISSUE_IDS_OR_KEYS = "issueIdsOrKeys";
  @SerializedName(SERIALIZED_NAME_ISSUE_IDS_OR_KEYS)
  @javax.annotation.Nullable
  private List<String> issueIdsOrKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_TARGET_CLASSIFICATION = "targetClassification";
  @SerializedName(SERIALIZED_NAME_TARGET_CLASSIFICATION)
  @javax.annotation.Nullable
  private List<TargetClassification> targetClassification;

  public static final String SERIALIZED_NAME_TARGET_MANDATORY_FIELDS = "targetMandatoryFields";
  @SerializedName(SERIALIZED_NAME_TARGET_MANDATORY_FIELDS)
  @javax.annotation.Nullable
  private List<TargetMandatoryFields> targetMandatoryFields;

  public static final String SERIALIZED_NAME_TARGET_STATUS = "targetStatus";
  @SerializedName(SERIALIZED_NAME_TARGET_STATUS)
  @javax.annotation.Nullable
  private List<TargetStatus> targetStatus;

  public TargetToSourcesMapping() {
  }

  public TargetToSourcesMapping inferClassificationDefaults(@javax.annotation.Nonnull Boolean inferClassificationDefaults) {
    this.inferClassificationDefaults = inferClassificationDefaults;
    return this;
  }

  /**
   * If &#x60;true&#x60;, when issues are moved into this target group, they will adopt the target project&#39;s default classification, if they don&#39;t have a classification already. If they do have a classification, it will be kept the same even after the move. Leave &#x60;targetClassification&#x60; empty when using this.  If &#x60;false&#x60;, you must provide a &#x60;targetClassification&#x60; mapping for each classification associated with the selected issues.  [Benefit from data classification](https://support.atlassian.com/security-and-access-policies/docs/what-is-data-classification/)
   * @return inferClassificationDefaults
   */
  @javax.annotation.Nonnull
  public Boolean getInferClassificationDefaults() {
    return inferClassificationDefaults;
  }

  public void setInferClassificationDefaults(@javax.annotation.Nonnull Boolean inferClassificationDefaults) {
    this.inferClassificationDefaults = inferClassificationDefaults;
  }


  public TargetToSourcesMapping inferFieldDefaults(@javax.annotation.Nonnull Boolean inferFieldDefaults) {
    this.inferFieldDefaults = inferFieldDefaults;
    return this;
  }

  /**
   * If &#x60;true&#x60;, values from the source issues will be retained for the mandatory fields in the field configuration of the destination project. The &#x60;targetMandatoryFields&#x60; property shouldn&#39;t be defined.  If &#x60;false&#x60;, the user is required to set values for mandatory fields present in the field configuration of the destination project. Provide input by defining the &#x60;targetMandatoryFields&#x60; property
   * @return inferFieldDefaults
   */
  @javax.annotation.Nonnull
  public Boolean getInferFieldDefaults() {
    return inferFieldDefaults;
  }

  public void setInferFieldDefaults(@javax.annotation.Nonnull Boolean inferFieldDefaults) {
    this.inferFieldDefaults = inferFieldDefaults;
  }


  public TargetToSourcesMapping inferStatusDefaults(@javax.annotation.Nonnull Boolean inferStatusDefaults) {
    this.inferStatusDefaults = inferStatusDefaults;
    return this;
  }

  /**
   * If &#x60;true&#x60;, the statuses of issues being moved in this target group that are not present in the target workflow will be changed to the default status of the target workflow (see below). Leave &#x60;targetStatus&#x60; empty when using this.  If &#x60;false&#x60;, you must provide a &#x60;targetStatus&#x60; for each status not present in the target workflow.  The default status in a workflow is referred to as the \&quot;initial status\&quot;. Each workflow has its own unique initial status. When an issue is created, it is automatically assigned to this initial status. Read more about configuring initial statuses: [Configure the initial status | Atlassian Support.](https://support.atlassian.com/jira-cloud-administration/docs/configure-the-initial-status/)
   * @return inferStatusDefaults
   */
  @javax.annotation.Nonnull
  public Boolean getInferStatusDefaults() {
    return inferStatusDefaults;
  }

  public void setInferStatusDefaults(@javax.annotation.Nonnull Boolean inferStatusDefaults) {
    this.inferStatusDefaults = inferStatusDefaults;
  }


  public TargetToSourcesMapping inferSubtaskTypeDefault(@javax.annotation.Nonnull Boolean inferSubtaskTypeDefault) {
    this.inferSubtaskTypeDefault = inferSubtaskTypeDefault;
    return this;
  }

  /**
   * When an issue is moved, its subtasks (if there are any) need to be moved with it. &#x60;inferSubtaskTypeDefault&#x60; helps with moving the subtasks by picking a random subtask type in the target project.  If &#x60;true&#x60;, subtasks will automatically move to the same project as their parent.  When they move:   *  Their &#x60;issueType&#x60; will be set to the default for subtasks in the target project.  *  Values for mandatory fields will be retained from the source issues  *  Specifying separate mapping for implicit subtasks won’t be allowed.  If &#x60;false&#x60;, you must manually move the subtasks. They will retain the parent which they had in the current project after being moved.
   * @return inferSubtaskTypeDefault
   */
  @javax.annotation.Nonnull
  public Boolean getInferSubtaskTypeDefault() {
    return inferSubtaskTypeDefault;
  }

  public void setInferSubtaskTypeDefault(@javax.annotation.Nonnull Boolean inferSubtaskTypeDefault) {
    this.inferSubtaskTypeDefault = inferSubtaskTypeDefault;
  }


  public TargetToSourcesMapping issueIdsOrKeys(@javax.annotation.Nullable List<String> issueIdsOrKeys) {
    this.issueIdsOrKeys = issueIdsOrKeys;
    return this;
  }

  public TargetToSourcesMapping addIssueIdsOrKeysItem(String issueIdsOrKeysItem) {
    if (this.issueIdsOrKeys == null) {
      this.issueIdsOrKeys = new ArrayList<>();
    }
    this.issueIdsOrKeys.add(issueIdsOrKeysItem);
    return this;
  }

  /**
   * List of issue IDs or keys to be moved. These issues must be from the same project, have the same issue type, and be from the same parent (if they’re subtasks).
   * @return issueIdsOrKeys
   */
  @javax.annotation.Nullable
  public List<String> getIssueIdsOrKeys() {
    return issueIdsOrKeys;
  }

  public void setIssueIdsOrKeys(@javax.annotation.Nullable List<String> issueIdsOrKeys) {
    this.issueIdsOrKeys = issueIdsOrKeys;
  }


  public TargetToSourcesMapping targetClassification(@javax.annotation.Nullable List<TargetClassification> targetClassification) {
    this.targetClassification = targetClassification;
    return this;
  }

  public TargetToSourcesMapping addTargetClassificationItem(TargetClassification targetClassificationItem) {
    if (this.targetClassification == null) {
      this.targetClassification = new ArrayList<>();
    }
    this.targetClassification.add(targetClassificationItem);
    return this;
  }

  /**
   * List of the objects containing classifications in the source issues and their new values which need to be set during the bulk move operation.   *  **You should only define this property when &#x60;inferClassificationDefaults&#x60; is &#x60;false&#x60;.**  *  **In order to provide mapping for issues which don&#39;t have a classification, use &#x60;\&quot;-1\&quot;&#x60;.**
   * @return targetClassification
   */
  @javax.annotation.Nullable
  public List<TargetClassification> getTargetClassification() {
    return targetClassification;
  }

  public void setTargetClassification(@javax.annotation.Nullable List<TargetClassification> targetClassification) {
    this.targetClassification = targetClassification;
  }


  public TargetToSourcesMapping targetMandatoryFields(@javax.annotation.Nullable List<TargetMandatoryFields> targetMandatoryFields) {
    this.targetMandatoryFields = targetMandatoryFields;
    return this;
  }

  public TargetToSourcesMapping addTargetMandatoryFieldsItem(TargetMandatoryFields targetMandatoryFieldsItem) {
    if (this.targetMandatoryFields == null) {
      this.targetMandatoryFields = new ArrayList<>();
    }
    this.targetMandatoryFields.add(targetMandatoryFieldsItem);
    return this;
  }

  /**
   * List of objects containing mandatory fields in the target field configuration and new values that need to be set during the bulk move operation.  The new values will only be applied if the field is mandatory in the target project and at least one issue from the source has that field empty, or if the field context is different in the target project (e.g. project-scoped version fields).  **You should only define this property when &#x60;inferFieldDefaults&#x60; is &#x60;false&#x60;.**
   * @return targetMandatoryFields
   */
  @javax.annotation.Nullable
  public List<TargetMandatoryFields> getTargetMandatoryFields() {
    return targetMandatoryFields;
  }

  public void setTargetMandatoryFields(@javax.annotation.Nullable List<TargetMandatoryFields> targetMandatoryFields) {
    this.targetMandatoryFields = targetMandatoryFields;
  }


  public TargetToSourcesMapping targetStatus(@javax.annotation.Nullable List<TargetStatus> targetStatus) {
    this.targetStatus = targetStatus;
    return this;
  }

  public TargetToSourcesMapping addTargetStatusItem(TargetStatus targetStatusItem) {
    if (this.targetStatus == null) {
      this.targetStatus = new ArrayList<>();
    }
    this.targetStatus.add(targetStatusItem);
    return this;
  }

  /**
   * List of the objects containing statuses in the source workflow and their new values which need to be set during the bulk move operation.  The new values will only be applied if the source status is invalid for the target project and issue type.  **You should only define this property when &#x60;inferStatusDefaults&#x60; is &#x60;false&#x60;.**
   * @return targetStatus
   */
  @javax.annotation.Nullable
  public List<TargetStatus> getTargetStatus() {
    return targetStatus;
  }

  public void setTargetStatus(@javax.annotation.Nullable List<TargetStatus> targetStatus) {
    this.targetStatus = targetStatus;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TargetToSourcesMapping targetToSourcesMapping = (TargetToSourcesMapping) o;
    return Objects.equals(this.inferClassificationDefaults, targetToSourcesMapping.inferClassificationDefaults) &&
        Objects.equals(this.inferFieldDefaults, targetToSourcesMapping.inferFieldDefaults) &&
        Objects.equals(this.inferStatusDefaults, targetToSourcesMapping.inferStatusDefaults) &&
        Objects.equals(this.inferSubtaskTypeDefault, targetToSourcesMapping.inferSubtaskTypeDefault) &&
        Objects.equals(this.issueIdsOrKeys, targetToSourcesMapping.issueIdsOrKeys) &&
        Objects.equals(this.targetClassification, targetToSourcesMapping.targetClassification) &&
        Objects.equals(this.targetMandatoryFields, targetToSourcesMapping.targetMandatoryFields) &&
        Objects.equals(this.targetStatus, targetToSourcesMapping.targetStatus);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(inferClassificationDefaults, inferFieldDefaults, inferStatusDefaults, inferSubtaskTypeDefault, issueIdsOrKeys, targetClassification, targetMandatoryFields, targetStatus);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TargetToSourcesMapping {\n");
    sb.append("    inferClassificationDefaults: ").append(toIndentedString(inferClassificationDefaults)).append("\n");
    sb.append("    inferFieldDefaults: ").append(toIndentedString(inferFieldDefaults)).append("\n");
    sb.append("    inferStatusDefaults: ").append(toIndentedString(inferStatusDefaults)).append("\n");
    sb.append("    inferSubtaskTypeDefault: ").append(toIndentedString(inferSubtaskTypeDefault)).append("\n");
    sb.append("    issueIdsOrKeys: ").append(toIndentedString(issueIdsOrKeys)).append("\n");
    sb.append("    targetClassification: ").append(toIndentedString(targetClassification)).append("\n");
    sb.append("    targetMandatoryFields: ").append(toIndentedString(targetMandatoryFields)).append("\n");
    sb.append("    targetStatus: ").append(toIndentedString(targetStatus)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("inferClassificationDefaults");
    openapiFields.add("inferFieldDefaults");
    openapiFields.add("inferStatusDefaults");
    openapiFields.add("inferSubtaskTypeDefault");
    openapiFields.add("issueIdsOrKeys");
    openapiFields.add("targetClassification");
    openapiFields.add("targetMandatoryFields");
    openapiFields.add("targetStatus");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("inferClassificationDefaults");
    openapiRequiredFields.add("inferFieldDefaults");
    openapiRequiredFields.add("inferStatusDefaults");
    openapiRequiredFields.add("inferSubtaskTypeDefault");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to TargetToSourcesMapping
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!TargetToSourcesMapping.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in TargetToSourcesMapping is not found in the empty JSON string", TargetToSourcesMapping.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!TargetToSourcesMapping.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `TargetToSourcesMapping` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : TargetToSourcesMapping.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("issueIdsOrKeys") != null && !jsonObj.get("issueIdsOrKeys").isJsonNull() && !jsonObj.get("issueIdsOrKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueIdsOrKeys` to be an array in the JSON string but got `%s`", jsonObj.get("issueIdsOrKeys").toString()));
      }
      if (jsonObj.get("targetClassification") != null && !jsonObj.get("targetClassification").isJsonNull()) {
        JsonArray jsonArraytargetClassification = jsonObj.getAsJsonArray("targetClassification");
        if (jsonArraytargetClassification != null) {
          // ensure the json data is an array
          if (!jsonObj.get("targetClassification").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `targetClassification` to be an array in the JSON string but got `%s`", jsonObj.get("targetClassification").toString()));
          }

          // validate the optional field `targetClassification` (array)
          for (int i = 0; i < jsonArraytargetClassification.size(); i++) {
            TargetClassification.validateJsonElement(jsonArraytargetClassification.get(i));
          };
        }
      }
      if (jsonObj.get("targetMandatoryFields") != null && !jsonObj.get("targetMandatoryFields").isJsonNull()) {
        JsonArray jsonArraytargetMandatoryFields = jsonObj.getAsJsonArray("targetMandatoryFields");
        if (jsonArraytargetMandatoryFields != null) {
          // ensure the json data is an array
          if (!jsonObj.get("targetMandatoryFields").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `targetMandatoryFields` to be an array in the JSON string but got `%s`", jsonObj.get("targetMandatoryFields").toString()));
          }

          // validate the optional field `targetMandatoryFields` (array)
          for (int i = 0; i < jsonArraytargetMandatoryFields.size(); i++) {
            TargetMandatoryFields.validateJsonElement(jsonArraytargetMandatoryFields.get(i));
          };
        }
      }
      if (jsonObj.get("targetStatus") != null && !jsonObj.get("targetStatus").isJsonNull()) {
        JsonArray jsonArraytargetStatus = jsonObj.getAsJsonArray("targetStatus");
        if (jsonArraytargetStatus != null) {
          // ensure the json data is an array
          if (!jsonObj.get("targetStatus").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `targetStatus` to be an array in the JSON string but got `%s`", jsonObj.get("targetStatus").toString()));
          }

          // validate the optional field `targetStatus` (array)
          for (int i = 0; i < jsonArraytargetStatus.size(); i++) {
            TargetStatus.validateJsonElement(jsonArraytargetStatus.get(i));
          };
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!TargetToSourcesMapping.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'TargetToSourcesMapping' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<TargetToSourcesMapping> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(TargetToSourcesMapping.class));

       return (TypeAdapter<T>) new TypeAdapter<TargetToSourcesMapping>() {
           @Override
           public void write(JsonWriter out, TargetToSourcesMapping value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public TargetToSourcesMapping read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             //validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of TargetToSourcesMapping given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of TargetToSourcesMapping
   * @throws IOException if the JSON string is invalid with respect to TargetToSourcesMapping
   */
  public static TargetToSourcesMapping fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, TargetToSourcesMapping.class);
  }

  /**
   * Convert an instance of TargetToSourcesMapping to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

