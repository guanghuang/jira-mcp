/*
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.software.model;

import java.util.Objects;
import com.atlassian.jira.software.model.Branch;
import com.atlassian.jira.software.model.Commit;
import com.atlassian.jira.software.model.PullRequest;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.invoker.JSON;

/**
 * Represents a repository, containing development information such as commits, pull requests, and branches.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-05T13:52:26.392070-04:00[America/New_York]", comments = "Generator version: 7.12.0")
public class Repository {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  @javax.annotation.Nullable
  private String description;

  public static final String SERIALIZED_NAME_FORK_OF = "forkOf";
  @SerializedName(SERIALIZED_NAME_FORK_OF)
  @javax.annotation.Nullable
  private String forkOf;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  @javax.annotation.Nonnull
  private String url;

  public static final String SERIALIZED_NAME_COMMITS = "commits";
  @SerializedName(SERIALIZED_NAME_COMMITS)
  @javax.annotation.Nullable
  private List<Commit> commits = new ArrayList<>();

  public static final String SERIALIZED_NAME_BRANCHES = "branches";
  @SerializedName(SERIALIZED_NAME_BRANCHES)
  @javax.annotation.Nullable
  private List<Branch> branches = new ArrayList<>();

  public static final String SERIALIZED_NAME_PULL_REQUESTS = "pullRequests";
  @SerializedName(SERIALIZED_NAME_PULL_REQUESTS)
  @javax.annotation.Nullable
  private List<PullRequest> pullRequests = new ArrayList<>();

  public static final String SERIALIZED_NAME_AVATAR = "avatar";
  @SerializedName(SERIALIZED_NAME_AVATAR)
  @javax.annotation.Nullable
  private String avatar;

  public static final String SERIALIZED_NAME_AVATAR_DESCRIPTION = "avatarDescription";
  @SerializedName(SERIALIZED_NAME_AVATAR_DESCRIPTION)
  @javax.annotation.Nullable
  private String avatarDescription;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nonnull
  private String id;

  public static final String SERIALIZED_NAME_UPDATE_SEQUENCE_ID = "updateSequenceId";
  @SerializedName(SERIALIZED_NAME_UPDATE_SEQUENCE_ID)
  @javax.annotation.Nonnull
  private Long updateSequenceId;

  public Repository() {
  }

  public Repository name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of this repository. Max length is 255 characters.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public Repository description(@javax.annotation.Nullable String description) {
    this.description = description;
    return this;
  }

  /**
   * Description of this repository. Max length is 1024 characters.
   * @return description
   */
  @javax.annotation.Nullable
  public String getDescription() {
    return description;
  }

  public void setDescription(@javax.annotation.Nullable String description) {
    this.description = description;
  }


  public Repository forkOf(@javax.annotation.Nullable String forkOf) {
    this.forkOf = forkOf;
    return this;
  }

  /**
   * The ID of the repository this repository was forked from, if it&#39;s a fork. Max length is 1024 characters.
   * @return forkOf
   */
  @javax.annotation.Nullable
  public String getForkOf() {
    return forkOf;
  }

  public void setForkOf(@javax.annotation.Nullable String forkOf) {
    this.forkOf = forkOf;
  }


  public Repository url(@javax.annotation.Nonnull String url) {
    this.url = url;
    return this;
  }

  /**
   * The URL of this repository. Max length is 2000 characters.
   * @return url
   */
  @javax.annotation.Nonnull
  public String getUrl() {
    return url;
  }

  public void setUrl(@javax.annotation.Nonnull String url) {
    this.url = url;
  }


  public Repository commits(@javax.annotation.Nullable List<Commit> commits) {
    this.commits = commits;
    return this;
  }

  public Repository addCommitsItem(Commit commitsItem) {
    if (this.commits == null) {
      this.commits = new ArrayList<>();
    }
    this.commits.add(commitsItem);
    return this;
  }

  /**
   * List of commits to update in this repository. Must not contain duplicate entity IDs. Maximum number of commits is 400
   * @return commits
   */
  @javax.annotation.Nullable
  public List<Commit> getCommits() {
    return commits;
  }

  public void setCommits(@javax.annotation.Nullable List<Commit> commits) {
    this.commits = commits;
  }


  public Repository branches(@javax.annotation.Nullable List<Branch> branches) {
    this.branches = branches;
    return this;
  }

  public Repository addBranchesItem(Branch branchesItem) {
    if (this.branches == null) {
      this.branches = new ArrayList<>();
    }
    this.branches.add(branchesItem);
    return this;
  }

  /**
   * List of branches to update in this repository. Must not contain duplicate entity IDs. Maximum number of branches is 400.
   * @return branches
   */
  @javax.annotation.Nullable
  public List<Branch> getBranches() {
    return branches;
  }

  public void setBranches(@javax.annotation.Nullable List<Branch> branches) {
    this.branches = branches;
  }


  public Repository pullRequests(@javax.annotation.Nullable List<PullRequest> pullRequests) {
    this.pullRequests = pullRequests;
    return this;
  }

  public Repository addPullRequestsItem(PullRequest pullRequestsItem) {
    if (this.pullRequests == null) {
      this.pullRequests = new ArrayList<>();
    }
    this.pullRequests.add(pullRequestsItem);
    return this;
  }

  /**
   * List of pull requests to update in this repository. Must not contain duplicate entity IDs. Maximum number of pull requests is 400
   * @return pullRequests
   */
  @javax.annotation.Nullable
  public List<PullRequest> getPullRequests() {
    return pullRequests;
  }

  public void setPullRequests(@javax.annotation.Nullable List<PullRequest> pullRequests) {
    this.pullRequests = pullRequests;
  }


  public Repository avatar(@javax.annotation.Nullable String avatar) {
    this.avatar = avatar;
    return this;
  }

  /**
   * The URL of the avatar for this repository. Max length is 2000 characters.
   * @return avatar
   */
  @javax.annotation.Nullable
  public String getAvatar() {
    return avatar;
  }

  public void setAvatar(@javax.annotation.Nullable String avatar) {
    this.avatar = avatar;
  }


  public Repository avatarDescription(@javax.annotation.Nullable String avatarDescription) {
    this.avatarDescription = avatarDescription;
    return this;
  }

  /**
   * Description of the avatar for this repository. Max length is 1024 characters.
   * @return avatarDescription
   */
  @javax.annotation.Nullable
  public String getAvatarDescription() {
    return avatarDescription;
  }

  public void setAvatarDescription(@javax.annotation.Nullable String avatarDescription) {
    this.avatarDescription = avatarDescription;
  }


  public Repository id(@javax.annotation.Nonnull String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID &#39;X&#39; in repository &#39;Y&#39;. But adding, e.g., a branch with ID &#39;X&#39; to repository &#39;Y&#39; is acceptable. Only alphanumeric characters, and &#39;~.-_&#39;, are allowed. Max length is 1024 characters.
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nonnull String id) {
    this.id = id;
  }


  public Repository updateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
    return this;
  }

  /**
   *  An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored.
   * @return updateSequenceId
   */
  @javax.annotation.Nonnull
  public Long getUpdateSequenceId() {
    return updateSequenceId;
  }

  public void setUpdateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Repository repository = (Repository) o;
    return Objects.equals(this.name, repository.name) &&
        Objects.equals(this.description, repository.description) &&
        Objects.equals(this.forkOf, repository.forkOf) &&
        Objects.equals(this.url, repository.url) &&
        Objects.equals(this.commits, repository.commits) &&
        Objects.equals(this.branches, repository.branches) &&
        Objects.equals(this.pullRequests, repository.pullRequests) &&
        Objects.equals(this.avatar, repository.avatar) &&
        Objects.equals(this.avatarDescription, repository.avatarDescription) &&
        Objects.equals(this.id, repository.id) &&
        Objects.equals(this.updateSequenceId, repository.updateSequenceId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, description, forkOf, url, commits, branches, pullRequests, avatar, avatarDescription, id, updateSequenceId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Repository {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    forkOf: ").append(toIndentedString(forkOf)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    commits: ").append(toIndentedString(commits)).append("\n");
    sb.append("    branches: ").append(toIndentedString(branches)).append("\n");
    sb.append("    pullRequests: ").append(toIndentedString(pullRequests)).append("\n");
    sb.append("    avatar: ").append(toIndentedString(avatar)).append("\n");
    sb.append("    avatarDescription: ").append(toIndentedString(avatarDescription)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    updateSequenceId: ").append(toIndentedString(updateSequenceId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("name");
    openapiFields.add("description");
    openapiFields.add("forkOf");
    openapiFields.add("url");
    openapiFields.add("commits");
    openapiFields.add("branches");
    openapiFields.add("pullRequests");
    openapiFields.add("avatar");
    openapiFields.add("avatarDescription");
    openapiFields.add("id");
    openapiFields.add("updateSequenceId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("url");
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("updateSequenceId");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Repository
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Repository.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Repository is not found in the empty JSON string", Repository.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Repository.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Repository` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Repository.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      if ((jsonObj.get("description") != null && !jsonObj.get("description").isJsonNull()) && !jsonObj.get("description").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `description` to be a primitive type in the JSON string but got `%s`", jsonObj.get("description").toString()));
      }
      if ((jsonObj.get("forkOf") != null && !jsonObj.get("forkOf").isJsonNull()) && !jsonObj.get("forkOf").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `forkOf` to be a primitive type in the JSON string but got `%s`", jsonObj.get("forkOf").toString()));
      }
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if (jsonObj.get("commits") != null && !jsonObj.get("commits").isJsonNull()) {
        JsonArray jsonArraycommits = jsonObj.getAsJsonArray("commits");
        if (jsonArraycommits != null) {
          // ensure the json data is an array
          if (!jsonObj.get("commits").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `commits` to be an array in the JSON string but got `%s`", jsonObj.get("commits").toString()));
          }

          // validate the optional field `commits` (array)
          for (int i = 0; i < jsonArraycommits.size(); i++) {
            Commit.validateJsonElement(jsonArraycommits.get(i));
          };
        }
      }
      if (jsonObj.get("branches") != null && !jsonObj.get("branches").isJsonNull()) {
        JsonArray jsonArraybranches = jsonObj.getAsJsonArray("branches");
        if (jsonArraybranches != null) {
          // ensure the json data is an array
          if (!jsonObj.get("branches").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `branches` to be an array in the JSON string but got `%s`", jsonObj.get("branches").toString()));
          }

          // validate the optional field `branches` (array)
          for (int i = 0; i < jsonArraybranches.size(); i++) {
            Branch.validateJsonElement(jsonArraybranches.get(i));
          };
        }
      }
      if (jsonObj.get("pullRequests") != null && !jsonObj.get("pullRequests").isJsonNull()) {
        JsonArray jsonArraypullRequests = jsonObj.getAsJsonArray("pullRequests");
        if (jsonArraypullRequests != null) {
          // ensure the json data is an array
          if (!jsonObj.get("pullRequests").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `pullRequests` to be an array in the JSON string but got `%s`", jsonObj.get("pullRequests").toString()));
          }

          // validate the optional field `pullRequests` (array)
          for (int i = 0; i < jsonArraypullRequests.size(); i++) {
            PullRequest.validateJsonElement(jsonArraypullRequests.get(i));
          };
        }
      }
      if ((jsonObj.get("avatar") != null && !jsonObj.get("avatar").isJsonNull()) && !jsonObj.get("avatar").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `avatar` to be a primitive type in the JSON string but got `%s`", jsonObj.get("avatar").toString()));
      }
      if ((jsonObj.get("avatarDescription") != null && !jsonObj.get("avatarDescription").isJsonNull()) && !jsonObj.get("avatarDescription").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `avatarDescription` to be a primitive type in the JSON string but got `%s`", jsonObj.get("avatarDescription").toString()));
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Repository.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Repository' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Repository> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Repository.class));

       return (TypeAdapter<T>) new TypeAdapter<Repository>() {
           @Override
           public void write(JsonWriter out, Repository value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Repository read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             //validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Repository given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Repository
   * @throws IOException if the JSON string is invalid with respect to Repository
   */
  public static Repository fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Repository.class);
  }

  /**
   * Convert an instance of Repository to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

