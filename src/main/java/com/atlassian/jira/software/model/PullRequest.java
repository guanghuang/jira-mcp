/*
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.software.model;

import java.util.Objects;
import com.atlassian.jira.software.model.Author;
import com.atlassian.jira.software.model.Reviewer;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.invoker.JSON;

/**
 * Represents a pull request
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-05T13:52:26.392070-04:00[America/New_York]", comments = "Generator version: 7.12.0")
public class PullRequest {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nonnull
  private String id;

  public static final String SERIALIZED_NAME_ISSUE_KEYS = "issueKeys";
  @SerializedName(SERIALIZED_NAME_ISSUE_KEYS)
  @javax.annotation.Nonnull
  private List<String> issueKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATE_SEQUENCE_ID = "updateSequenceId";
  @SerializedName(SERIALIZED_NAME_UPDATE_SEQUENCE_ID)
  @javax.annotation.Nonnull
  private Long updateSequenceId;

  /**
   * The status of the pull request. In the case of concurrent updates, priority is given in the order OPEN, MERGED, DECLINED, UNKNOWN
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    OPEN("OPEN"),
    
    MERGED("MERGED"),
    
    DECLINED("DECLINED"),
    
    UNKNOWN("UNKNOWN");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static StatusEnum fromValue(String value) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return StatusEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      StatusEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  @javax.annotation.Nonnull
  private StatusEnum status;

  public static final String SERIALIZED_NAME_TITLE = "title";
  @SerializedName(SERIALIZED_NAME_TITLE)
  @javax.annotation.Nonnull
  private String title;

  public static final String SERIALIZED_NAME_AUTHOR = "author";
  @SerializedName(SERIALIZED_NAME_AUTHOR)
  @javax.annotation.Nonnull
  private Author author;

  public static final String SERIALIZED_NAME_COMMENT_COUNT = "commentCount";
  @SerializedName(SERIALIZED_NAME_COMMENT_COUNT)
  @javax.annotation.Nonnull
  private Integer commentCount;

  public static final String SERIALIZED_NAME_SOURCE_BRANCH = "sourceBranch";
  @SerializedName(SERIALIZED_NAME_SOURCE_BRANCH)
  @javax.annotation.Nonnull
  private String sourceBranch;

  public static final String SERIALIZED_NAME_SOURCE_BRANCH_URL = "sourceBranchUrl";
  @SerializedName(SERIALIZED_NAME_SOURCE_BRANCH_URL)
  @javax.annotation.Nullable
  private String sourceBranchUrl;

  public static final String SERIALIZED_NAME_LAST_UPDATE = "lastUpdate";
  @SerializedName(SERIALIZED_NAME_LAST_UPDATE)
  @javax.annotation.Nonnull
  private String lastUpdate;

  public static final String SERIALIZED_NAME_DESTINATION_BRANCH = "destinationBranch";
  @SerializedName(SERIALIZED_NAME_DESTINATION_BRANCH)
  @javax.annotation.Nullable
  private String destinationBranch;

  public static final String SERIALIZED_NAME_DESTINATION_BRANCH_URL = "destinationBranchUrl";
  @SerializedName(SERIALIZED_NAME_DESTINATION_BRANCH_URL)
  @javax.annotation.Nullable
  private String destinationBranchUrl;

  public static final String SERIALIZED_NAME_REVIEWERS = "reviewers";
  @SerializedName(SERIALIZED_NAME_REVIEWERS)
  @javax.annotation.Nullable
  private List<Reviewer> reviewers = new ArrayList<>();

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  @javax.annotation.Nonnull
  private String url;

  public static final String SERIALIZED_NAME_DISPLAY_ID = "displayId";
  @SerializedName(SERIALIZED_NAME_DISPLAY_ID)
  @javax.annotation.Nonnull
  private String displayId;

  public PullRequest() {
  }

  public PullRequest id(@javax.annotation.Nonnull String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID &#39;X&#39; in repository &#39;Y&#39;. But adding, e.g., a branch with ID &#39;X&#39; to repository &#39;Y&#39; is acceptable. Only alphanumeric characters, and &#39;~.-_&#39;, are allowed. Max length is 1024 characters
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nonnull String id) {
    this.id = id;
  }


  public PullRequest issueKeys(@javax.annotation.Nonnull List<String> issueKeys) {
    this.issueKeys = issueKeys;
    return this;
  }

  public PullRequest addIssueKeysItem(String issueKeysItem) {
    if (this.issueKeys == null) {
      this.issueKeys = new ArrayList<>();
    }
    this.issueKeys.add(issueKeysItem);
    return this;
  }

  /**
   * List of issues keys that this entity is associated with. They must be valid Jira issue keys.
   * @return issueKeys
   */
  @javax.annotation.Nonnull
  public List<String> getIssueKeys() {
    return issueKeys;
  }

  public void setIssueKeys(@javax.annotation.Nonnull List<String> issueKeys) {
    this.issueKeys = issueKeys;
  }


  public PullRequest updateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
    return this;
  }

  /**
   * An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored.
   * @return updateSequenceId
   */
  @javax.annotation.Nonnull
  public Long getUpdateSequenceId() {
    return updateSequenceId;
  }

  public void setUpdateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
  }


  public PullRequest status(@javax.annotation.Nonnull StatusEnum status) {
    this.status = status;
    return this;
  }

  /**
   * The status of the pull request. In the case of concurrent updates, priority is given in the order OPEN, MERGED, DECLINED, UNKNOWN
   * @return status
   */
  @javax.annotation.Nonnull
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(@javax.annotation.Nonnull StatusEnum status) {
    this.status = status;
  }


  public PullRequest title(@javax.annotation.Nonnull String title) {
    this.title = title;
    return this;
  }

  /**
   * Title of the pull request. Max length is 1024 characters.
   * @return title
   */
  @javax.annotation.Nonnull
  public String getTitle() {
    return title;
  }

  public void setTitle(@javax.annotation.Nonnull String title) {
    this.title = title;
  }


  public PullRequest author(@javax.annotation.Nonnull Author author) {
    this.author = author;
    return this;
  }

  /**
   * Get author
   * @return author
   */
  @javax.annotation.Nonnull
  public Author getAuthor() {
    return author;
  }

  public void setAuthor(@javax.annotation.Nonnull Author author) {
    this.author = author;
  }


  public PullRequest commentCount(@javax.annotation.Nonnull Integer commentCount) {
    this.commentCount = commentCount;
    return this;
  }

  /**
   * The number of comments on the pull request
   * @return commentCount
   */
  @javax.annotation.Nonnull
  public Integer getCommentCount() {
    return commentCount;
  }

  public void setCommentCount(@javax.annotation.Nonnull Integer commentCount) {
    this.commentCount = commentCount;
  }


  public PullRequest sourceBranch(@javax.annotation.Nonnull String sourceBranch) {
    this.sourceBranch = sourceBranch;
    return this;
  }

  /**
   * The name of the source branch of this PR. Max length is 255 characters.
   * @return sourceBranch
   */
  @javax.annotation.Nonnull
  public String getSourceBranch() {
    return sourceBranch;
  }

  public void setSourceBranch(@javax.annotation.Nonnull String sourceBranch) {
    this.sourceBranch = sourceBranch;
  }


  public PullRequest sourceBranchUrl(@javax.annotation.Nullable String sourceBranchUrl) {
    this.sourceBranchUrl = sourceBranchUrl;
    return this;
  }

  /**
   * The url of the source branch of this PR. This is used to match this PR against the branch. Max length is 2000 characters.
   * @return sourceBranchUrl
   */
  @javax.annotation.Nullable
  public String getSourceBranchUrl() {
    return sourceBranchUrl;
  }

  public void setSourceBranchUrl(@javax.annotation.Nullable String sourceBranchUrl) {
    this.sourceBranchUrl = sourceBranchUrl;
  }


  public PullRequest lastUpdate(@javax.annotation.Nonnull String lastUpdate) {
    this.lastUpdate = lastUpdate;
    return this;
  }

  /**
   * The most recent update to this PR. Formatted as a UTC ISO 8601 date time format.
   * @return lastUpdate
   */
  @javax.annotation.Nonnull
  public String getLastUpdate() {
    return lastUpdate;
  }

  public void setLastUpdate(@javax.annotation.Nonnull String lastUpdate) {
    this.lastUpdate = lastUpdate;
  }


  public PullRequest destinationBranch(@javax.annotation.Nullable String destinationBranch) {
    this.destinationBranch = destinationBranch;
    return this;
  }

  /**
   * The name of destination branch of this PR. Max length is 255 characters.
   * @return destinationBranch
   */
  @javax.annotation.Nullable
  public String getDestinationBranch() {
    return destinationBranch;
  }

  public void setDestinationBranch(@javax.annotation.Nullable String destinationBranch) {
    this.destinationBranch = destinationBranch;
  }


  public PullRequest destinationBranchUrl(@javax.annotation.Nullable String destinationBranchUrl) {
    this.destinationBranchUrl = destinationBranchUrl;
    return this;
  }

  /**
   * The url of the destination branch of this PR. Max length is 2000 characters.
   * @return destinationBranchUrl
   */
  @javax.annotation.Nullable
  public String getDestinationBranchUrl() {
    return destinationBranchUrl;
  }

  public void setDestinationBranchUrl(@javax.annotation.Nullable String destinationBranchUrl) {
    this.destinationBranchUrl = destinationBranchUrl;
  }


  public PullRequest reviewers(@javax.annotation.Nullable List<Reviewer> reviewers) {
    this.reviewers = reviewers;
    return this;
  }

  public PullRequest addReviewersItem(Reviewer reviewersItem) {
    if (this.reviewers == null) {
      this.reviewers = new ArrayList<>();
    }
    this.reviewers.add(reviewersItem);
    return this;
  }

  /**
   * The list of reviewers of this pull request
   * @return reviewers
   */
  @javax.annotation.Nullable
  public List<Reviewer> getReviewers() {
    return reviewers;
  }

  public void setReviewers(@javax.annotation.Nullable List<Reviewer> reviewers) {
    this.reviewers = reviewers;
  }


  public PullRequest url(@javax.annotation.Nonnull String url) {
    this.url = url;
    return this;
  }

  /**
   * The URL of this pull request. Max length is 2000 characters.
   * @return url
   */
  @javax.annotation.Nonnull
  public String getUrl() {
    return url;
  }

  public void setUrl(@javax.annotation.Nonnull String url) {
    this.url = url;
  }


  public PullRequest displayId(@javax.annotation.Nonnull String displayId) {
    this.displayId = displayId;
    return this;
  }

  /**
   * Shortened identifier for this pull request, used for display. Max length is 255 characters.
   * @return displayId
   */
  @javax.annotation.Nonnull
  public String getDisplayId() {
    return displayId;
  }

  public void setDisplayId(@javax.annotation.Nonnull String displayId) {
    this.displayId = displayId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PullRequest pullRequest = (PullRequest) o;
    return Objects.equals(this.id, pullRequest.id) &&
        Objects.equals(this.issueKeys, pullRequest.issueKeys) &&
        Objects.equals(this.updateSequenceId, pullRequest.updateSequenceId) &&
        Objects.equals(this.status, pullRequest.status) &&
        Objects.equals(this.title, pullRequest.title) &&
        Objects.equals(this.author, pullRequest.author) &&
        Objects.equals(this.commentCount, pullRequest.commentCount) &&
        Objects.equals(this.sourceBranch, pullRequest.sourceBranch) &&
        Objects.equals(this.sourceBranchUrl, pullRequest.sourceBranchUrl) &&
        Objects.equals(this.lastUpdate, pullRequest.lastUpdate) &&
        Objects.equals(this.destinationBranch, pullRequest.destinationBranch) &&
        Objects.equals(this.destinationBranchUrl, pullRequest.destinationBranchUrl) &&
        Objects.equals(this.reviewers, pullRequest.reviewers) &&
        Objects.equals(this.url, pullRequest.url) &&
        Objects.equals(this.displayId, pullRequest.displayId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, issueKeys, updateSequenceId, status, title, author, commentCount, sourceBranch, sourceBranchUrl, lastUpdate, destinationBranch, destinationBranchUrl, reviewers, url, displayId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PullRequest {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    issueKeys: ").append(toIndentedString(issueKeys)).append("\n");
    sb.append("    updateSequenceId: ").append(toIndentedString(updateSequenceId)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    author: ").append(toIndentedString(author)).append("\n");
    sb.append("    commentCount: ").append(toIndentedString(commentCount)).append("\n");
    sb.append("    sourceBranch: ").append(toIndentedString(sourceBranch)).append("\n");
    sb.append("    sourceBranchUrl: ").append(toIndentedString(sourceBranchUrl)).append("\n");
    sb.append("    lastUpdate: ").append(toIndentedString(lastUpdate)).append("\n");
    sb.append("    destinationBranch: ").append(toIndentedString(destinationBranch)).append("\n");
    sb.append("    destinationBranchUrl: ").append(toIndentedString(destinationBranchUrl)).append("\n");
    sb.append("    reviewers: ").append(toIndentedString(reviewers)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    displayId: ").append(toIndentedString(displayId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("issueKeys");
    openapiFields.add("updateSequenceId");
    openapiFields.add("status");
    openapiFields.add("title");
    openapiFields.add("author");
    openapiFields.add("commentCount");
    openapiFields.add("sourceBranch");
    openapiFields.add("sourceBranchUrl");
    openapiFields.add("lastUpdate");
    openapiFields.add("destinationBranch");
    openapiFields.add("destinationBranchUrl");
    openapiFields.add("reviewers");
    openapiFields.add("url");
    openapiFields.add("displayId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("issueKeys");
    openapiRequiredFields.add("updateSequenceId");
    openapiRequiredFields.add("status");
    openapiRequiredFields.add("title");
    openapiRequiredFields.add("author");
    openapiRequiredFields.add("commentCount");
    openapiRequiredFields.add("sourceBranch");
    openapiRequiredFields.add("lastUpdate");
    openapiRequiredFields.add("url");
    openapiRequiredFields.add("displayId");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to PullRequest
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!PullRequest.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in PullRequest is not found in the empty JSON string", PullRequest.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!PullRequest.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `PullRequest` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : PullRequest.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("issueKeys") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("issueKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueKeys` to be an array in the JSON string but got `%s`", jsonObj.get("issueKeys").toString()));
      }
      if (!jsonObj.get("status").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `status` to be a primitive type in the JSON string but got `%s`", jsonObj.get("status").toString()));
      }
      // validate the required field `status`
      StatusEnum.validateJsonElement(jsonObj.get("status"));
      if (!jsonObj.get("title").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `title` to be a primitive type in the JSON string but got `%s`", jsonObj.get("title").toString()));
      }
      // validate the required field `author`
      Author.validateJsonElement(jsonObj.get("author"));
      if (!jsonObj.get("sourceBranch").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceBranch` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceBranch").toString()));
      }
      if ((jsonObj.get("sourceBranchUrl") != null && !jsonObj.get("sourceBranchUrl").isJsonNull()) && !jsonObj.get("sourceBranchUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `sourceBranchUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("sourceBranchUrl").toString()));
      }
      if (!jsonObj.get("lastUpdate").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `lastUpdate` to be a primitive type in the JSON string but got `%s`", jsonObj.get("lastUpdate").toString()));
      }
      if ((jsonObj.get("destinationBranch") != null && !jsonObj.get("destinationBranch").isJsonNull()) && !jsonObj.get("destinationBranch").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destinationBranch` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destinationBranch").toString()));
      }
      if ((jsonObj.get("destinationBranchUrl") != null && !jsonObj.get("destinationBranchUrl").isJsonNull()) && !jsonObj.get("destinationBranchUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `destinationBranchUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("destinationBranchUrl").toString()));
      }
      if (jsonObj.get("reviewers") != null && !jsonObj.get("reviewers").isJsonNull()) {
        JsonArray jsonArrayreviewers = jsonObj.getAsJsonArray("reviewers");
        if (jsonArrayreviewers != null) {
          // ensure the json data is an array
          if (!jsonObj.get("reviewers").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `reviewers` to be an array in the JSON string but got `%s`", jsonObj.get("reviewers").toString()));
          }

          // validate the optional field `reviewers` (array)
          for (int i = 0; i < jsonArrayreviewers.size(); i++) {
            Reviewer.validateJsonElement(jsonArrayreviewers.get(i));
          };
        }
      }
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if (!jsonObj.get("displayId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!PullRequest.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'PullRequest' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<PullRequest> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(PullRequest.class));

       return (TypeAdapter<T>) new TypeAdapter<PullRequest>() {
           @Override
           public void write(JsonWriter out, PullRequest value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public PullRequest read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             //validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of PullRequest given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of PullRequest
   * @throws IOException if the JSON string is invalid with respect to PullRequest
   */
  public static PullRequest fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, PullRequest.class);
  }

  /**
   * Convert an instance of PullRequest to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

