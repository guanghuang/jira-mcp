/*
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.software.model;

import java.util.Objects;
import com.atlassian.jira.software.model.Author;
import com.atlassian.jira.software.model.ModelFile;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.invoker.JSON;

/**
 * Represents a commit in the version control system.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-05T13:52:26.392070-04:00[America/New_York]", comments = "Generator version: 7.12.0")
public class Commit {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nonnull
  private String id;

  public static final String SERIALIZED_NAME_ISSUE_KEYS = "issueKeys";
  @SerializedName(SERIALIZED_NAME_ISSUE_KEYS)
  @javax.annotation.Nonnull
  private List<String> issueKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATE_SEQUENCE_ID = "updateSequenceId";
  @SerializedName(SERIALIZED_NAME_UPDATE_SEQUENCE_ID)
  @javax.annotation.Nonnull
  private Long updateSequenceId;

  public static final String SERIALIZED_NAME_HASH = "hash";
  @SerializedName(SERIALIZED_NAME_HASH)
  @javax.annotation.Nullable
  private String hash;

  /**
   * Gets or Sets flags
   */
  @JsonAdapter(FlagsEnum.Adapter.class)
  public enum FlagsEnum {
    MERGE_COMMIT("MERGE_COMMIT");

    private String value;

    FlagsEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static FlagsEnum fromValue(String value) {
      for (FlagsEnum b : FlagsEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<FlagsEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final FlagsEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public FlagsEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return FlagsEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      FlagsEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_FLAGS = "flags";
  @SerializedName(SERIALIZED_NAME_FLAGS)
  @javax.annotation.Nullable
  private Set<FlagsEnum> flags = new LinkedHashSet<>();

  public static final String SERIALIZED_NAME_MESSAGE = "message";
  @SerializedName(SERIALIZED_NAME_MESSAGE)
  @javax.annotation.Nonnull
  private String message;

  public static final String SERIALIZED_NAME_AUTHOR = "author";
  @SerializedName(SERIALIZED_NAME_AUTHOR)
  @javax.annotation.Nonnull
  private Author author;

  public static final String SERIALIZED_NAME_FILE_COUNT = "fileCount";
  @SerializedName(SERIALIZED_NAME_FILE_COUNT)
  @javax.annotation.Nonnull
  private Integer fileCount;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  @javax.annotation.Nonnull
  private String url;

  public static final String SERIALIZED_NAME_FILES = "files";
  @SerializedName(SERIALIZED_NAME_FILES)
  @javax.annotation.Nullable
  private List<ModelFile> files = new ArrayList<>();

  public static final String SERIALIZED_NAME_AUTHOR_TIMESTAMP = "authorTimestamp";
  @SerializedName(SERIALIZED_NAME_AUTHOR_TIMESTAMP)
  @javax.annotation.Nonnull
  private String authorTimestamp;

  public static final String SERIALIZED_NAME_DISPLAY_ID = "displayId";
  @SerializedName(SERIALIZED_NAME_DISPLAY_ID)
  @javax.annotation.Nonnull
  private String displayId;

  public Commit() {
  }

  public Commit id(@javax.annotation.Nonnull String id) {
    this.id = id;
    return this;
  }

  /**
   * The identifier or hash of the commit. Will be used for cross entity linking. Must be unique for all commits within a repository, i.e., only one commit can have ID &#39;X&#39; in repository &#39;Y&#39;. But adding, e.g., a branch with ID &#39;X&#39; to repository &#39;Y&#39; is acceptable. Only alphanumeric characters, and &#39;~.-_&#39;, are allowed. Max length is 1024 characters
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nonnull String id) {
    this.id = id;
  }


  public Commit issueKeys(@javax.annotation.Nonnull List<String> issueKeys) {
    this.issueKeys = issueKeys;
    return this;
  }

  public Commit addIssueKeysItem(String issueKeysItem) {
    if (this.issueKeys == null) {
      this.issueKeys = new ArrayList<>();
    }
    this.issueKeys.add(issueKeysItem);
    return this;
  }

  /**
   * List of issues keys that this entity is associated with. They must be valid Jira issue keys.
   * @return issueKeys
   */
  @javax.annotation.Nonnull
  public List<String> getIssueKeys() {
    return issueKeys;
  }

  public void setIssueKeys(@javax.annotation.Nonnull List<String> issueKeys) {
    this.issueKeys = issueKeys;
  }


  public Commit updateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
    return this;
  }

  /**
   * An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored.
   * @return updateSequenceId
   */
  @javax.annotation.Nonnull
  public Long getUpdateSequenceId() {
    return updateSequenceId;
  }

  public void setUpdateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
  }


  public Commit hash(@javax.annotation.Nullable String hash) {
    this.hash = hash;
    return this;
  }

  /**
   * Deprecated. Use the id field instead.
   * @return hash
   */
  @javax.annotation.Nullable
  public String getHash() {
    return hash;
  }

  public void setHash(@javax.annotation.Nullable String hash) {
    this.hash = hash;
  }


  public Commit flags(@javax.annotation.Nullable Set<FlagsEnum> flags) {
    this.flags = flags;
    return this;
  }

  public Commit addFlagsItem(FlagsEnum flagsItem) {
    if (this.flags == null) {
      this.flags = new LinkedHashSet<>();
    }
    this.flags.add(flagsItem);
    return this;
  }

  /**
   * The set of flags for this commit
   * @return flags
   */
  @javax.annotation.Nullable
  public Set<FlagsEnum> getFlags() {
    return flags;
  }

  public void setFlags(@javax.annotation.Nullable Set<FlagsEnum> flags) {
    this.flags = flags;
  }


  public Commit message(@javax.annotation.Nonnull String message) {
    this.message = message;
    return this;
  }

  /**
   * The commit message. Max length is 1024 characters. If anything longer is supplied, it will be truncated down to 1024 characters.
   * @return message
   */
  @javax.annotation.Nonnull
  public String getMessage() {
    return message;
  }

  public void setMessage(@javax.annotation.Nonnull String message) {
    this.message = message;
  }


  public Commit author(@javax.annotation.Nonnull Author author) {
    this.author = author;
    return this;
  }

  /**
   * Get author
   * @return author
   */
  @javax.annotation.Nonnull
  public Author getAuthor() {
    return author;
  }

  public void setAuthor(@javax.annotation.Nonnull Author author) {
    this.author = author;
  }


  public Commit fileCount(@javax.annotation.Nonnull Integer fileCount) {
    this.fileCount = fileCount;
    return this;
  }

  /**
   * The total number of files added, removed, or modified by this commit
   * minimum: 0
   * @return fileCount
   */
  @javax.annotation.Nonnull
  public Integer getFileCount() {
    return fileCount;
  }

  public void setFileCount(@javax.annotation.Nonnull Integer fileCount) {
    this.fileCount = fileCount;
  }


  public Commit url(@javax.annotation.Nonnull String url) {
    this.url = url;
    return this;
  }

  /**
   * The URL of this commit. Max length is 2000 characters.
   * @return url
   */
  @javax.annotation.Nonnull
  public String getUrl() {
    return url;
  }

  public void setUrl(@javax.annotation.Nonnull String url) {
    this.url = url;
  }


  public Commit files(@javax.annotation.Nullable List<ModelFile> files) {
    this.files = files;
    return this;
  }

  public Commit addFilesItem(ModelFile filesItem) {
    if (this.files == null) {
      this.files = new ArrayList<>();
    }
    this.files.add(filesItem);
    return this;
  }

  /**
   * List of file changes. Max number of files is 10. Currently, only the first 5 files are shown (sorted by path) in the UI. This UI behavior may change without notice.
   * @return files
   */
  @javax.annotation.Nullable
  public List<ModelFile> getFiles() {
    return files;
  }

  public void setFiles(@javax.annotation.Nullable List<ModelFile> files) {
    this.files = files;
  }


  public Commit authorTimestamp(@javax.annotation.Nonnull String authorTimestamp) {
    this.authorTimestamp = authorTimestamp;
    return this;
  }

  /**
   * The author timestamp of this commit. Formatted as a UTC ISO 8601 date time format.
   * @return authorTimestamp
   */
  @javax.annotation.Nonnull
  public String getAuthorTimestamp() {
    return authorTimestamp;
  }

  public void setAuthorTimestamp(@javax.annotation.Nonnull String authorTimestamp) {
    this.authorTimestamp = authorTimestamp;
  }


  public Commit displayId(@javax.annotation.Nonnull String displayId) {
    this.displayId = displayId;
    return this;
  }

  /**
   * Shortened identifier for this commit, used for display. Max length is 255 characters.
   * @return displayId
   */
  @javax.annotation.Nonnull
  public String getDisplayId() {
    return displayId;
  }

  public void setDisplayId(@javax.annotation.Nonnull String displayId) {
    this.displayId = displayId;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Commit commit = (Commit) o;
    return Objects.equals(this.id, commit.id) &&
        Objects.equals(this.issueKeys, commit.issueKeys) &&
        Objects.equals(this.updateSequenceId, commit.updateSequenceId) &&
        Objects.equals(this.hash, commit.hash) &&
        Objects.equals(this.flags, commit.flags) &&
        Objects.equals(this.message, commit.message) &&
        Objects.equals(this.author, commit.author) &&
        Objects.equals(this.fileCount, commit.fileCount) &&
        Objects.equals(this.url, commit.url) &&
        Objects.equals(this.files, commit.files) &&
        Objects.equals(this.authorTimestamp, commit.authorTimestamp) &&
        Objects.equals(this.displayId, commit.displayId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, issueKeys, updateSequenceId, hash, flags, message, author, fileCount, url, files, authorTimestamp, displayId);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Commit {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    issueKeys: ").append(toIndentedString(issueKeys)).append("\n");
    sb.append("    updateSequenceId: ").append(toIndentedString(updateSequenceId)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    flags: ").append(toIndentedString(flags)).append("\n");
    sb.append("    message: ").append(toIndentedString(message)).append("\n");
    sb.append("    author: ").append(toIndentedString(author)).append("\n");
    sb.append("    fileCount: ").append(toIndentedString(fileCount)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    files: ").append(toIndentedString(files)).append("\n");
    sb.append("    authorTimestamp: ").append(toIndentedString(authorTimestamp)).append("\n");
    sb.append("    displayId: ").append(toIndentedString(displayId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("issueKeys");
    openapiFields.add("updateSequenceId");
    openapiFields.add("hash");
    openapiFields.add("flags");
    openapiFields.add("message");
    openapiFields.add("author");
    openapiFields.add("fileCount");
    openapiFields.add("url");
    openapiFields.add("files");
    openapiFields.add("authorTimestamp");
    openapiFields.add("displayId");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("issueKeys");
    openapiRequiredFields.add("updateSequenceId");
    openapiRequiredFields.add("message");
    openapiRequiredFields.add("author");
    openapiRequiredFields.add("fileCount");
    openapiRequiredFields.add("url");
    openapiRequiredFields.add("authorTimestamp");
    openapiRequiredFields.add("displayId");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Commit
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Commit.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Commit is not found in the empty JSON string", Commit.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Commit.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Commit` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Commit.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("issueKeys") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("issueKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueKeys` to be an array in the JSON string but got `%s`", jsonObj.get("issueKeys").toString()));
      }
      if ((jsonObj.get("hash") != null && !jsonObj.get("hash").isJsonNull()) && !jsonObj.get("hash").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `hash` to be a primitive type in the JSON string but got `%s`", jsonObj.get("hash").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("flags") != null && !jsonObj.get("flags").isJsonNull() && !jsonObj.get("flags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `flags` to be an array in the JSON string but got `%s`", jsonObj.get("flags").toString()));
      }
      if (!jsonObj.get("message").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `message` to be a primitive type in the JSON string but got `%s`", jsonObj.get("message").toString()));
      }
      // validate the required field `author`
      Author.validateJsonElement(jsonObj.get("author"));
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
      if (jsonObj.get("files") != null && !jsonObj.get("files").isJsonNull()) {
        JsonArray jsonArrayfiles = jsonObj.getAsJsonArray("files");
        if (jsonArrayfiles != null) {
          // ensure the json data is an array
          if (!jsonObj.get("files").isJsonArray()) {
            throw new IllegalArgumentException(String.format("Expected the field `files` to be an array in the JSON string but got `%s`", jsonObj.get("files").toString()));
          }

          // validate the optional field `files` (array)
          for (int i = 0; i < jsonArrayfiles.size(); i++) {
            ModelFile.validateJsonElement(jsonArrayfiles.get(i));
          };
        }
      }
      if (!jsonObj.get("authorTimestamp").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `authorTimestamp` to be a primitive type in the JSON string but got `%s`", jsonObj.get("authorTimestamp").toString()));
      }
      if (!jsonObj.get("displayId").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayId` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayId").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Commit.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Commit' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Commit> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Commit.class));

       return (TypeAdapter<T>) new TypeAdapter<Commit>() {
           @Override
           public void write(JsonWriter out, Commit value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Commit read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             //validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Commit given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Commit
   * @throws IOException if the JSON string is invalid with respect to Commit
   */
  public static Commit fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Commit.class);
  }

  /**
   * Convert an instance of Commit to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

