/*
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.software.model;

import java.util.Objects;
import com.atlassian.jira.software.model.EntityIds;
import com.atlassian.jira.software.model.RepositoryErrors;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.invoker.JSON;

/**
 * The result of a successful store development information request
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-05T13:52:26.392070-04:00[America/New_York]", comments = "Generator version: 7.12.0")
public class StoreDevinfoResult {
  public static final String SERIALIZED_NAME_ACCEPTED_DEVINFO_ENTITIES = "acceptedDevinfoEntities";
  @SerializedName(SERIALIZED_NAME_ACCEPTED_DEVINFO_ENTITIES)
  @javax.annotation.Nullable
  private Map<String, EntityIds> acceptedDevinfoEntities = new HashMap<>();

  public static final String SERIALIZED_NAME_FAILED_DEVINFO_ENTITIES = "failedDevinfoEntities";
  @SerializedName(SERIALIZED_NAME_FAILED_DEVINFO_ENTITIES)
  @javax.annotation.Nullable
  private Map<String, RepositoryErrors> failedDevinfoEntities = new HashMap<>();

  public static final String SERIALIZED_NAME_UNKNOWN_ISSUE_KEYS = "unknownIssueKeys";
  @SerializedName(SERIALIZED_NAME_UNKNOWN_ISSUE_KEYS)
  @javax.annotation.Nullable
  private List<String> unknownIssueKeys = new ArrayList<>();

  public StoreDevinfoResult() {
  }

  public StoreDevinfoResult acceptedDevinfoEntities(@javax.annotation.Nullable Map<String, EntityIds> acceptedDevinfoEntities) {
    this.acceptedDevinfoEntities = acceptedDevinfoEntities;
    return this;
  }

  public StoreDevinfoResult putAcceptedDevinfoEntitiesItem(String key, EntityIds acceptedDevinfoEntitiesItem) {
    if (this.acceptedDevinfoEntities == null) {
      this.acceptedDevinfoEntities = new HashMap<>();
    }
    this.acceptedDevinfoEntities.put(key, acceptedDevinfoEntitiesItem);
    return this;
  }

  /**
   * The IDs of devinfo entities that have been accepted for submission grouped by their repository IDs. Note that a devinfo entity that isn&#39;t updated due to it&#39;s updateSequenceId being out of order is not considered a failed submission.
   * @return acceptedDevinfoEntities
   */
  @javax.annotation.Nullable
  public Map<String, EntityIds> getAcceptedDevinfoEntities() {
    return acceptedDevinfoEntities;
  }

  public void setAcceptedDevinfoEntities(@javax.annotation.Nullable Map<String, EntityIds> acceptedDevinfoEntities) {
    this.acceptedDevinfoEntities = acceptedDevinfoEntities;
  }


  public StoreDevinfoResult failedDevinfoEntities(@javax.annotation.Nullable Map<String, RepositoryErrors> failedDevinfoEntities) {
    this.failedDevinfoEntities = failedDevinfoEntities;
    return this;
  }

  public StoreDevinfoResult putFailedDevinfoEntitiesItem(String key, RepositoryErrors failedDevinfoEntitiesItem) {
    if (this.failedDevinfoEntities == null) {
      this.failedDevinfoEntities = new HashMap<>();
    }
    this.failedDevinfoEntities.put(key, failedDevinfoEntitiesItem);
    return this;
  }

  /**
   * IDs of devinfo entities that have not been accepted for submission and caused error descriptions, usually due to a problem with the request data. The entities (if present) will be grouped by their repository id and type. Entity IDs are listed with errors associated with that devinfo entity that have prevented it being submitted. 
   * @return failedDevinfoEntities
   */
  @javax.annotation.Nullable
  public Map<String, RepositoryErrors> getFailedDevinfoEntities() {
    return failedDevinfoEntities;
  }

  public void setFailedDevinfoEntities(@javax.annotation.Nullable Map<String, RepositoryErrors> failedDevinfoEntities) {
    this.failedDevinfoEntities = failedDevinfoEntities;
  }


  public StoreDevinfoResult unknownIssueKeys(@javax.annotation.Nullable List<String> unknownIssueKeys) {
    this.unknownIssueKeys = unknownIssueKeys;
    return this;
  }

  public StoreDevinfoResult addUnknownIssueKeysItem(String unknownIssueKeysItem) {
    if (this.unknownIssueKeys == null) {
      this.unknownIssueKeys = new ArrayList<>();
    }
    this.unknownIssueKeys.add(unknownIssueKeysItem);
    return this;
  }

  /**
   * Issue keys that are not known on this Jira instance (if any). These may be invalid keys (e.g. &#x60;UTF-8&#x60; is sometimes incorrectly identified as a Jira issue key), or they may be for projects that no longer exist. If a devinfo entity has been associated with issue keys other than those in this array it will still be stored against those valid keys. 
   * @return unknownIssueKeys
   */
  @javax.annotation.Nullable
  public List<String> getUnknownIssueKeys() {
    return unknownIssueKeys;
  }

  public void setUnknownIssueKeys(@javax.annotation.Nullable List<String> unknownIssueKeys) {
    this.unknownIssueKeys = unknownIssueKeys;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StoreDevinfoResult storeDevinfoResult = (StoreDevinfoResult) o;
    return Objects.equals(this.acceptedDevinfoEntities, storeDevinfoResult.acceptedDevinfoEntities) &&
        Objects.equals(this.failedDevinfoEntities, storeDevinfoResult.failedDevinfoEntities) &&
        Objects.equals(this.unknownIssueKeys, storeDevinfoResult.unknownIssueKeys);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptedDevinfoEntities, failedDevinfoEntities, unknownIssueKeys);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StoreDevinfoResult {\n");
    sb.append("    acceptedDevinfoEntities: ").append(toIndentedString(acceptedDevinfoEntities)).append("\n");
    sb.append("    failedDevinfoEntities: ").append(toIndentedString(failedDevinfoEntities)).append("\n");
    sb.append("    unknownIssueKeys: ").append(toIndentedString(unknownIssueKeys)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acceptedDevinfoEntities");
    openapiFields.add("failedDevinfoEntities");
    openapiFields.add("unknownIssueKeys");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to StoreDevinfoResult
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!StoreDevinfoResult.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in StoreDevinfoResult is not found in the empty JSON string", StoreDevinfoResult.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!StoreDevinfoResult.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `StoreDevinfoResult` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("unknownIssueKeys") != null && !jsonObj.get("unknownIssueKeys").isJsonNull() && !jsonObj.get("unknownIssueKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `unknownIssueKeys` to be an array in the JSON string but got `%s`", jsonObj.get("unknownIssueKeys").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!StoreDevinfoResult.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'StoreDevinfoResult' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<StoreDevinfoResult> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(StoreDevinfoResult.class));

       return (TypeAdapter<T>) new TypeAdapter<StoreDevinfoResult>() {
           @Override
           public void write(JsonWriter out, StoreDevinfoResult value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public StoreDevinfoResult read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             //validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of StoreDevinfoResult given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of StoreDevinfoResult
   * @throws IOException if the JSON string is invalid with respect to StoreDevinfoResult
   */
  public static StoreDevinfoResult fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, StoreDevinfoResult.class);
  }

  /**
   * Convert an instance of StoreDevinfoResult to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

