/*
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.software.model;

import java.util.Objects;
import com.atlassian.jira.software.model.ErrorMessage1;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.invoker.JSON;

/**
 * The result of a successful submitFeatureFlags request. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-05T13:52:26.392070-04:00[America/New_York]", comments = "Generator version: 7.12.0")
public class SubmitFeatureFlagsResponse {
  public static final String SERIALIZED_NAME_ACCEPTED_FEATURE_FLAGS = "acceptedFeatureFlags";
  @SerializedName(SERIALIZED_NAME_ACCEPTED_FEATURE_FLAGS)
  @javax.annotation.Nullable
  private List<String> acceptedFeatureFlags = new ArrayList<>();

  public static final String SERIALIZED_NAME_FAILED_FEATURE_FLAGS = "failedFeatureFlags";
  @SerializedName(SERIALIZED_NAME_FAILED_FEATURE_FLAGS)
  @javax.annotation.Nullable
  private Map<String, List<ErrorMessage1>> failedFeatureFlags = new HashMap<>();

  public static final String SERIALIZED_NAME_UNKNOWN_ISSUE_KEYS = "unknownIssueKeys";
  @SerializedName(SERIALIZED_NAME_UNKNOWN_ISSUE_KEYS)
  @javax.annotation.Nullable
  private List<String> unknownIssueKeys = new ArrayList<>();

  public SubmitFeatureFlagsResponse() {
  }

  public SubmitFeatureFlagsResponse acceptedFeatureFlags(@javax.annotation.Nullable List<String> acceptedFeatureFlags) {
    this.acceptedFeatureFlags = acceptedFeatureFlags;
    return this;
  }

  public SubmitFeatureFlagsResponse addAcceptedFeatureFlagsItem(String acceptedFeatureFlagsItem) {
    if (this.acceptedFeatureFlags == null) {
      this.acceptedFeatureFlags = new ArrayList<>();
    }
    this.acceptedFeatureFlags.add(acceptedFeatureFlagsItem);
    return this;
  }

  /**
   * The IDs of Feature Flags that have been accepted for submission.  A Feature Flag may be rejected if it was only associated with unknown issue keys.  Note that a Feature Flag that isn&#39;t updated due to it&#39;s updateSequenceId being out of order is not considered a failed submission. 
   * @return acceptedFeatureFlags
   */
  @javax.annotation.Nullable
  public List<String> getAcceptedFeatureFlags() {
    return acceptedFeatureFlags;
  }

  public void setAcceptedFeatureFlags(@javax.annotation.Nullable List<String> acceptedFeatureFlags) {
    this.acceptedFeatureFlags = acceptedFeatureFlags;
  }


  public SubmitFeatureFlagsResponse failedFeatureFlags(@javax.annotation.Nullable Map<String, List<ErrorMessage1>> failedFeatureFlags) {
    this.failedFeatureFlags = failedFeatureFlags;
    return this;
  }

  public SubmitFeatureFlagsResponse putFailedFeatureFlagsItem(String key, List<ErrorMessage1> failedFeatureFlagsItem) {
    if (this.failedFeatureFlags == null) {
      this.failedFeatureFlags = new HashMap<>();
    }
    this.failedFeatureFlags.put(key, failedFeatureFlagsItem);
    return this;
  }

  /**
   * Details of Feature Flags that have not been accepted for submission, usually due to a problem with the request data.  The object (if present) will be keyed by Feature Flag ID and include any errors associated with that Feature Flag that have prevented it being submitted. 
   * @return failedFeatureFlags
   */
  @javax.annotation.Nullable
  public Map<String, List<ErrorMessage1>> getFailedFeatureFlags() {
    return failedFeatureFlags;
  }

  public void setFailedFeatureFlags(@javax.annotation.Nullable Map<String, List<ErrorMessage1>> failedFeatureFlags) {
    this.failedFeatureFlags = failedFeatureFlags;
  }


  public SubmitFeatureFlagsResponse unknownIssueKeys(@javax.annotation.Nullable List<String> unknownIssueKeys) {
    this.unknownIssueKeys = unknownIssueKeys;
    return this;
  }

  public SubmitFeatureFlagsResponse addUnknownIssueKeysItem(String unknownIssueKeysItem) {
    if (this.unknownIssueKeys == null) {
      this.unknownIssueKeys = new ArrayList<>();
    }
    this.unknownIssueKeys.add(unknownIssueKeysItem);
    return this;
  }

  /**
   * Issue keys that are not known on this Jira instance (if any).   These may be invalid keys (e.g. &#x60;UTF-8&#x60; is sometimes incorrectly identified as a Jira issue key), or they may be for projects that no longer exist.  If a Feature Flag has been associated with issue keys other than those in this array it will still be stored against those valid keys. If a Feature Flag was only associated with issue keys deemed to be invalid it won&#39;t be persisted. 
   * @return unknownIssueKeys
   */
  @javax.annotation.Nullable
  public List<String> getUnknownIssueKeys() {
    return unknownIssueKeys;
  }

  public void setUnknownIssueKeys(@javax.annotation.Nullable List<String> unknownIssueKeys) {
    this.unknownIssueKeys = unknownIssueKeys;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SubmitFeatureFlagsResponse submitFeatureFlagsResponse = (SubmitFeatureFlagsResponse) o;
    return Objects.equals(this.acceptedFeatureFlags, submitFeatureFlagsResponse.acceptedFeatureFlags) &&
        Objects.equals(this.failedFeatureFlags, submitFeatureFlagsResponse.failedFeatureFlags) &&
        Objects.equals(this.unknownIssueKeys, submitFeatureFlagsResponse.unknownIssueKeys);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptedFeatureFlags, failedFeatureFlags, unknownIssueKeys);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SubmitFeatureFlagsResponse {\n");
    sb.append("    acceptedFeatureFlags: ").append(toIndentedString(acceptedFeatureFlags)).append("\n");
    sb.append("    failedFeatureFlags: ").append(toIndentedString(failedFeatureFlags)).append("\n");
    sb.append("    unknownIssueKeys: ").append(toIndentedString(unknownIssueKeys)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("acceptedFeatureFlags");
    openapiFields.add("failedFeatureFlags");
    openapiFields.add("unknownIssueKeys");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SubmitFeatureFlagsResponse
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!SubmitFeatureFlagsResponse.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in SubmitFeatureFlagsResponse is not found in the empty JSON string", SubmitFeatureFlagsResponse.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!SubmitFeatureFlagsResponse.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `SubmitFeatureFlagsResponse` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      // ensure the optional json data is an array if present
      if (jsonObj.get("acceptedFeatureFlags") != null && !jsonObj.get("acceptedFeatureFlags").isJsonNull() && !jsonObj.get("acceptedFeatureFlags").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `acceptedFeatureFlags` to be an array in the JSON string but got `%s`", jsonObj.get("acceptedFeatureFlags").toString()));
      }
      // ensure the optional json data is an array if present
      if (jsonObj.get("unknownIssueKeys") != null && !jsonObj.get("unknownIssueKeys").isJsonNull() && !jsonObj.get("unknownIssueKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `unknownIssueKeys` to be an array in the JSON string but got `%s`", jsonObj.get("unknownIssueKeys").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!SubmitFeatureFlagsResponse.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'SubmitFeatureFlagsResponse' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<SubmitFeatureFlagsResponse> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(SubmitFeatureFlagsResponse.class));

       return (TypeAdapter<T>) new TypeAdapter<SubmitFeatureFlagsResponse>() {
           @Override
           public void write(JsonWriter out, SubmitFeatureFlagsResponse value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public SubmitFeatureFlagsResponse read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             //validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of SubmitFeatureFlagsResponse given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SubmitFeatureFlagsResponse
   * @throws IOException if the JSON string is invalid with respect to SubmitFeatureFlagsResponse
   */
  public static SubmitFeatureFlagsResponse fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SubmitFeatureFlagsResponse.class);
  }

  /**
   * Convert an instance of SubmitFeatureFlagsResponse to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

