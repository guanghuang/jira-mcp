/*
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.software.model;

import java.util.Objects;
import com.atlassian.jira.software.model.FeatureFlagDetails;
import com.atlassian.jira.software.model.FeatureFlagSummary;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.invoker.JSON;

/**
 * Data related to a single Feature Flag, across any Environment that the flag is present in. 
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-05T13:52:26.392070-04:00[America/New_York]", comments = "Generator version: 7.12.0")
public class FeatureFlagData {
  /**
   * The FeatureFlagData schema version used for this flag data.   Placeholder to support potential schema changes in the future. 
   */
  @JsonAdapter(SchemaVersionEnum.Adapter.class)
  public enum SchemaVersionEnum {
    _1_0("1.0");

    private String value;

    SchemaVersionEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static SchemaVersionEnum fromValue(String value) {
      for (SchemaVersionEnum b : SchemaVersionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<SchemaVersionEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final SchemaVersionEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public SchemaVersionEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return SchemaVersionEnum.fromValue(value);
      }
    }

    public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      String value = jsonElement.getAsString();
      SchemaVersionEnum.fromValue(value);
    }
  }

  public static final String SERIALIZED_NAME_SCHEMA_VERSION = "schemaVersion";
  @SerializedName(SERIALIZED_NAME_SCHEMA_VERSION)
  @javax.annotation.Nullable
  private SchemaVersionEnum schemaVersion = SchemaVersionEnum._1_0;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nonnull
  private String id;

  public static final String SERIALIZED_NAME_KEY = "key";
  @SerializedName(SERIALIZED_NAME_KEY)
  @javax.annotation.Nonnull
  private String key;

  public static final String SERIALIZED_NAME_UPDATE_SEQUENCE_ID = "updateSequenceId";
  @SerializedName(SERIALIZED_NAME_UPDATE_SEQUENCE_ID)
  @javax.annotation.Nonnull
  private Long updateSequenceId;

  public static final String SERIALIZED_NAME_DISPLAY_NAME = "displayName";
  @SerializedName(SERIALIZED_NAME_DISPLAY_NAME)
  @javax.annotation.Nullable
  private String displayName;

  public static final String SERIALIZED_NAME_ISSUE_KEYS = "issueKeys";
  @SerializedName(SERIALIZED_NAME_ISSUE_KEYS)
  @javax.annotation.Nonnull
  private List<String> issueKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_SUMMARY = "summary";
  @SerializedName(SERIALIZED_NAME_SUMMARY)
  @javax.annotation.Nonnull
  private FeatureFlagSummary summary;

  public static final String SERIALIZED_NAME_DETAILS = "details";
  @SerializedName(SERIALIZED_NAME_DETAILS)
  @javax.annotation.Nonnull
  private List<FeatureFlagDetails> details = new ArrayList<>();

  public FeatureFlagData() {
  }

  public FeatureFlagData schemaVersion(@javax.annotation.Nullable SchemaVersionEnum schemaVersion) {
    this.schemaVersion = schemaVersion;
    return this;
  }

  /**
   * The FeatureFlagData schema version used for this flag data.   Placeholder to support potential schema changes in the future. 
   * @return schemaVersion
   */
  @javax.annotation.Nullable
  public SchemaVersionEnum getSchemaVersion() {
    return schemaVersion;
  }

  public void setSchemaVersion(@javax.annotation.Nullable SchemaVersionEnum schemaVersion) {
    this.schemaVersion = schemaVersion;
  }


  public FeatureFlagData id(@javax.annotation.Nonnull String id) {
    this.id = id;
    return this;
  }

  /**
   * The identifier for the Feature Flag. Must be unique for a given Provider. 
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nonnull String id) {
    this.id = id;
  }


  public FeatureFlagData key(@javax.annotation.Nonnull String key) {
    this.key = key;
    return this;
  }

  /**
   * The identifier that users would use to reference the Feature Flag in their source code etc.  Will be made available via the UI for users to copy into their source code etc. 
   * @return key
   */
  @javax.annotation.Nonnull
  public String getKey() {
    return key;
  }

  public void setKey(@javax.annotation.Nonnull String key) {
    this.key = key;
  }


  public FeatureFlagData updateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
    return this;
  }

  /**
   * An ID used to apply an ordering to updates for this Feature Flag in the case of out-of-order receipt of update requests.  This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the Provider system, but other alternatives are valid (e.g. a Provider could store a counter against each Feature Flag and increment that on each update to Jira).  Updates for a Feature Flag that are received with an updateSqeuenceId lower than what is currently stored will be ignored. 
   * @return updateSequenceId
   */
  @javax.annotation.Nonnull
  public Long getUpdateSequenceId() {
    return updateSequenceId;
  }

  public void setUpdateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
  }


  public FeatureFlagData displayName(@javax.annotation.Nullable String displayName) {
    this.displayName = displayName;
    return this;
  }

  /**
   * The human-readable name for the Feature Flag. Will be shown in the UI.  If not provided, will use the ID for display. 
   * @return displayName
   */
  @javax.annotation.Nullable
  public String getDisplayName() {
    return displayName;
  }

  public void setDisplayName(@javax.annotation.Nullable String displayName) {
    this.displayName = displayName;
  }


  public FeatureFlagData issueKeys(@javax.annotation.Nonnull List<String> issueKeys) {
    this.issueKeys = issueKeys;
    return this;
  }

  public FeatureFlagData addIssueKeysItem(String issueKeysItem) {
    if (this.issueKeys == null) {
      this.issueKeys = new ArrayList<>();
    }
    this.issueKeys.add(issueKeysItem);
    return this;
  }

  /**
   * The Jira issue keys to associate the Feature Flag information with. 
   * @return issueKeys
   */
  @javax.annotation.Nonnull
  public List<String> getIssueKeys() {
    return issueKeys;
  }

  public void setIssueKeys(@javax.annotation.Nonnull List<String> issueKeys) {
    this.issueKeys = issueKeys;
  }


  public FeatureFlagData summary(@javax.annotation.Nonnull FeatureFlagSummary summary) {
    this.summary = summary;
    return this;
  }

  /**
   * Get summary
   * @return summary
   */
  @javax.annotation.Nonnull
  public FeatureFlagSummary getSummary() {
    return summary;
  }

  public void setSummary(@javax.annotation.Nonnull FeatureFlagSummary summary) {
    this.summary = summary;
  }


  public FeatureFlagData details(@javax.annotation.Nonnull List<FeatureFlagDetails> details) {
    this.details = details;
    return this;
  }

  public FeatureFlagData addDetailsItem(FeatureFlagDetails detailsItem) {
    if (this.details == null) {
      this.details = new ArrayList<>();
    }
    this.details.add(detailsItem);
    return this;
  }

  /**
   * Detail information for this Feature Flag.  This may be information for each environment the Feature Flag is defined in or a selection of environments made by the user, as appropriate. 
   * @return details
   */
  @javax.annotation.Nonnull
  public List<FeatureFlagDetails> getDetails() {
    return details;
  }

  public void setDetails(@javax.annotation.Nonnull List<FeatureFlagDetails> details) {
    this.details = details;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FeatureFlagData featureFlagData = (FeatureFlagData) o;
    return Objects.equals(this.schemaVersion, featureFlagData.schemaVersion) &&
        Objects.equals(this.id, featureFlagData.id) &&
        Objects.equals(this.key, featureFlagData.key) &&
        Objects.equals(this.updateSequenceId, featureFlagData.updateSequenceId) &&
        Objects.equals(this.displayName, featureFlagData.displayName) &&
        Objects.equals(this.issueKeys, featureFlagData.issueKeys) &&
        Objects.equals(this.summary, featureFlagData.summary) &&
        Objects.equals(this.details, featureFlagData.details);
  }

  @Override
  public int hashCode() {
    return Objects.hash(schemaVersion, id, key, updateSequenceId, displayName, issueKeys, summary, details);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FeatureFlagData {\n");
    sb.append("    schemaVersion: ").append(toIndentedString(schemaVersion)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    key: ").append(toIndentedString(key)).append("\n");
    sb.append("    updateSequenceId: ").append(toIndentedString(updateSequenceId)).append("\n");
    sb.append("    displayName: ").append(toIndentedString(displayName)).append("\n");
    sb.append("    issueKeys: ").append(toIndentedString(issueKeys)).append("\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("    details: ").append(toIndentedString(details)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("schemaVersion");
    openapiFields.add("id");
    openapiFields.add("key");
    openapiFields.add("updateSequenceId");
    openapiFields.add("displayName");
    openapiFields.add("issueKeys");
    openapiFields.add("summary");
    openapiFields.add("details");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("key");
    openapiRequiredFields.add("updateSequenceId");
    openapiRequiredFields.add("issueKeys");
    openapiRequiredFields.add("summary");
    openapiRequiredFields.add("details");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to FeatureFlagData
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!FeatureFlagData.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in FeatureFlagData is not found in the empty JSON string", FeatureFlagData.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!FeatureFlagData.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `FeatureFlagData` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : FeatureFlagData.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if ((jsonObj.get("schemaVersion") != null && !jsonObj.get("schemaVersion").isJsonNull()) && !jsonObj.get("schemaVersion").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `schemaVersion` to be a primitive type in the JSON string but got `%s`", jsonObj.get("schemaVersion").toString()));
      }
      // validate the optional field `schemaVersion`
      if (jsonObj.get("schemaVersion") != null && !jsonObj.get("schemaVersion").isJsonNull()) {
        SchemaVersionEnum.validateJsonElement(jsonObj.get("schemaVersion"));
      }
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      if (!jsonObj.get("key").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `key` to be a primitive type in the JSON string but got `%s`", jsonObj.get("key").toString()));
      }
      if ((jsonObj.get("displayName") != null && !jsonObj.get("displayName").isJsonNull()) && !jsonObj.get("displayName").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `displayName` to be a primitive type in the JSON string but got `%s`", jsonObj.get("displayName").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("issueKeys") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("issueKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueKeys` to be an array in the JSON string but got `%s`", jsonObj.get("issueKeys").toString()));
      }
      // validate the required field `summary`
      FeatureFlagSummary.validateJsonElement(jsonObj.get("summary"));
      // ensure the json data is an array
      if (!jsonObj.get("details").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `details` to be an array in the JSON string but got `%s`", jsonObj.get("details").toString()));
      }

      JsonArray jsonArraydetails = jsonObj.getAsJsonArray("details");
      // validate the required field `details` (array)
      for (int i = 0; i < jsonArraydetails.size(); i++) {
        FeatureFlagDetails.validateJsonElement(jsonArraydetails.get(i));
      };
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!FeatureFlagData.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'FeatureFlagData' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<FeatureFlagData> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(FeatureFlagData.class));

       return (TypeAdapter<T>) new TypeAdapter<FeatureFlagData>() {
           @Override
           public void write(JsonWriter out, FeatureFlagData value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public FeatureFlagData read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             //validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of FeatureFlagData given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of FeatureFlagData
   * @throws IOException if the JSON string is invalid with respect to FeatureFlagData
   */
  public static FeatureFlagData fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, FeatureFlagData.class);
  }

  /**
   * Convert an instance of FeatureFlagData to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

