/*
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.software.model;

import java.util.Objects;
import com.atlassian.jira.software.model.Commit;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.atlassian.jira.invoker.JSON;

/**
 * Represents a branch in the version control system
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-04-05T13:52:26.392070-04:00[America/New_York]", comments = "Generator version: 7.12.0")
public class Branch {
  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nonnull
  private String id;

  public static final String SERIALIZED_NAME_ISSUE_KEYS = "issueKeys";
  @SerializedName(SERIALIZED_NAME_ISSUE_KEYS)
  @javax.annotation.Nonnull
  private List<String> issueKeys = new ArrayList<>();

  public static final String SERIALIZED_NAME_UPDATE_SEQUENCE_ID = "updateSequenceId";
  @SerializedName(SERIALIZED_NAME_UPDATE_SEQUENCE_ID)
  @javax.annotation.Nonnull
  private Long updateSequenceId;

  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  @javax.annotation.Nonnull
  private String name;

  public static final String SERIALIZED_NAME_LAST_COMMIT = "lastCommit";
  @SerializedName(SERIALIZED_NAME_LAST_COMMIT)
  @javax.annotation.Nonnull
  private Commit lastCommit;

  public static final String SERIALIZED_NAME_CREATE_PULL_REQUEST_URL = "createPullRequestUrl";
  @SerializedName(SERIALIZED_NAME_CREATE_PULL_REQUEST_URL)
  @javax.annotation.Nullable
  private String createPullRequestUrl;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  @javax.annotation.Nonnull
  private String url;

  public Branch() {
  }

  public Branch id(@javax.annotation.Nonnull String id) {
    this.id = id;
    return this;
  }

  /**
   * The ID of this entity. Will be used for cross entity linking. Must be unique by entity type within a repository, i.e., only one commit can have ID &#39;X&#39; in repository &#39;Y&#39;. But adding, e.g., a branch with ID &#39;X&#39; to repository &#39;Y&#39; is acceptable. Only alphanumeric characters, and &#39;~.-_&#39;, are allowed. Max length is 1024 characters.
   * @return id
   */
  @javax.annotation.Nonnull
  public String getId() {
    return id;
  }

  public void setId(@javax.annotation.Nonnull String id) {
    this.id = id;
  }


  public Branch issueKeys(@javax.annotation.Nonnull List<String> issueKeys) {
    this.issueKeys = issueKeys;
    return this;
  }

  public Branch addIssueKeysItem(String issueKeysItem) {
    if (this.issueKeys == null) {
      this.issueKeys = new ArrayList<>();
    }
    this.issueKeys.add(issueKeysItem);
    return this;
  }

  /**
   * List of issues keys that this entity is associated with. They must be valid Jira issue keys.
   * @return issueKeys
   */
  @javax.annotation.Nonnull
  public List<String> getIssueKeys() {
    return issueKeys;
  }

  public void setIssueKeys(@javax.annotation.Nonnull List<String> issueKeys) {
    this.issueKeys = issueKeys;
  }


  public Branch updateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
    return this;
  }

  /**
   * An ID used to apply an ordering to updates for this entity in the case of out-of-order receipt of update requests. This can be any monotonically increasing number. A suggested implementation is to use epoch millis from the provider system, but other alternatives are valid (e.g. a provider could store a counter against each entity and increment that on each update to Jira). Updates for an entity that are received with an updateSqeuenceId lower than what is currently stored will be ignored.
   * @return updateSequenceId
   */
  @javax.annotation.Nonnull
  public Long getUpdateSequenceId() {
    return updateSequenceId;
  }

  public void setUpdateSequenceId(@javax.annotation.Nonnull Long updateSequenceId) {
    this.updateSequenceId = updateSequenceId;
  }


  public Branch name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * The name of the branch. Max length is 512 characters.
   * @return name
   */
  @javax.annotation.Nonnull
  public String getName() {
    return name;
  }

  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public Branch lastCommit(@javax.annotation.Nonnull Commit lastCommit) {
    this.lastCommit = lastCommit;
    return this;
  }

  /**
   * Get lastCommit
   * @return lastCommit
   */
  @javax.annotation.Nonnull
  public Commit getLastCommit() {
    return lastCommit;
  }

  public void setLastCommit(@javax.annotation.Nonnull Commit lastCommit) {
    this.lastCommit = lastCommit;
  }


  public Branch createPullRequestUrl(@javax.annotation.Nullable String createPullRequestUrl) {
    this.createPullRequestUrl = createPullRequestUrl;
    return this;
  }

  /**
   * The URL of the page for creating a pull request from this branch. Max length is 2000 characters.
   * @return createPullRequestUrl
   */
  @javax.annotation.Nullable
  public String getCreatePullRequestUrl() {
    return createPullRequestUrl;
  }

  public void setCreatePullRequestUrl(@javax.annotation.Nullable String createPullRequestUrl) {
    this.createPullRequestUrl = createPullRequestUrl;
  }


  public Branch url(@javax.annotation.Nonnull String url) {
    this.url = url;
    return this;
  }

  /**
   * The URL of the branch. Max length is 2000 characters.
   * @return url
   */
  @javax.annotation.Nonnull
  public String getUrl() {
    return url;
  }

  public void setUrl(@javax.annotation.Nonnull String url) {
    this.url = url;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Branch branch = (Branch) o;
    return Objects.equals(this.id, branch.id) &&
        Objects.equals(this.issueKeys, branch.issueKeys) &&
        Objects.equals(this.updateSequenceId, branch.updateSequenceId) &&
        Objects.equals(this.name, branch.name) &&
        Objects.equals(this.lastCommit, branch.lastCommit) &&
        Objects.equals(this.createPullRequestUrl, branch.createPullRequestUrl) &&
        Objects.equals(this.url, branch.url);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, issueKeys, updateSequenceId, name, lastCommit, createPullRequestUrl, url);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Branch {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    issueKeys: ").append(toIndentedString(issueKeys)).append("\n");
    sb.append("    updateSequenceId: ").append(toIndentedString(updateSequenceId)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    lastCommit: ").append(toIndentedString(lastCommit)).append("\n");
    sb.append("    createPullRequestUrl: ").append(toIndentedString(createPullRequestUrl)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("id");
    openapiFields.add("issueKeys");
    openapiFields.add("updateSequenceId");
    openapiFields.add("name");
    openapiFields.add("lastCommit");
    openapiFields.add("createPullRequestUrl");
    openapiFields.add("url");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("id");
    openapiRequiredFields.add("issueKeys");
    openapiRequiredFields.add("updateSequenceId");
    openapiRequiredFields.add("name");
    openapiRequiredFields.add("lastCommit");
    openapiRequiredFields.add("url");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to Branch
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
      if (jsonElement == null) {
        if (!Branch.openapiRequiredFields.isEmpty()) { // has required fields but JSON element is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in Branch is not found in the empty JSON string", Branch.openapiRequiredFields.toString()));
        }
      }

      Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
      // check to see if the JSON string contains additional fields
      for (Map.Entry<String, JsonElement> entry : entries) {
        if (!Branch.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `Branch` properties. JSON: %s", entry.getKey(), jsonElement.toString()));
        }
      }

      // check to make sure all required properties/fields are present in the JSON string
      for (String requiredField : Branch.openapiRequiredFields) {
        if (jsonElement.getAsJsonObject().get(requiredField) == null) {
          throw new IllegalArgumentException(String.format("The required field `%s` is not found in the JSON string: %s", requiredField, jsonElement.toString()));
        }
      }
        JsonObject jsonObj = jsonElement.getAsJsonObject();
      if (!jsonObj.get("id").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `id` to be a primitive type in the JSON string but got `%s`", jsonObj.get("id").toString()));
      }
      // ensure the required json array is present
      if (jsonObj.get("issueKeys") == null) {
        throw new IllegalArgumentException("Expected the field `linkedContent` to be an array in the JSON string but got `null`");
      } else if (!jsonObj.get("issueKeys").isJsonArray()) {
        throw new IllegalArgumentException(String.format("Expected the field `issueKeys` to be an array in the JSON string but got `%s`", jsonObj.get("issueKeys").toString()));
      }
      if (!jsonObj.get("name").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `name` to be a primitive type in the JSON string but got `%s`", jsonObj.get("name").toString()));
      }
      // validate the required field `lastCommit`
      Commit.validateJsonElement(jsonObj.get("lastCommit"));
      if ((jsonObj.get("createPullRequestUrl") != null && !jsonObj.get("createPullRequestUrl").isJsonNull()) && !jsonObj.get("createPullRequestUrl").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `createPullRequestUrl` to be a primitive type in the JSON string but got `%s`", jsonObj.get("createPullRequestUrl").toString()));
      }
      if (!jsonObj.get("url").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `url` to be a primitive type in the JSON string but got `%s`", jsonObj.get("url").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!Branch.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'Branch' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<Branch> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(Branch.class));

       return (TypeAdapter<T>) new TypeAdapter<Branch>() {
           @Override
           public void write(JsonWriter out, Branch value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public Branch read(JsonReader in) throws IOException {
             JsonElement jsonElement = elementAdapter.read(in);
             //validateJsonElement(jsonElement);
             return thisAdapter.fromJsonTree(jsonElement);
           }

       }.nullSafe();
    }
  }

  /**
   * Create an instance of Branch given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of Branch
   * @throws IOException if the JSON string is invalid with respect to Branch
   */
  public static Branch fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, Branch.class);
  }

  /**
   * Convert an instance of Branch to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

