/*
 * Jira Software Cloud API
 * Jira Software Cloud REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.atlassian.jira.software.api;

import com.atlassian.jira.invoker.ApiCallback;
import com.atlassian.jira.invoker.ApiClient;
import com.atlassian.jira.invoker.ApiException;
import com.atlassian.jira.invoker.ApiResponse;
import com.atlassian.jira.invoker.Configuration;
import com.atlassian.jira.invoker.Pair;
import com.atlassian.jira.invoker.ProgressRequestBody;
import com.atlassian.jira.invoker.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.atlassian.jira.software.model.ErrorMessage1;
import com.atlassian.jira.software.model.SecurityWorkspaceIds;
import com.atlassian.jira.software.model.SecurityWorkspaceResponse;
import com.atlassian.jira.software.model.SubmitSecurityWorkspacesRequest;
import com.atlassian.jira.software.model.SubmitVulnerabilitiesRequest;
import com.atlassian.jira.software.model.SubmitVulnerabilitiesResponse;
import com.atlassian.jira.software.model.VulnerabilityDetails;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class SecurityInformationApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public SecurityInformationApi() {
        this(Configuration.getDefaultApiClient());
    }

    public SecurityInformationApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for deleteLinkedWorkspaces
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read [understanding jwt](https://developer.atlassian.com/blog/2015/01/understanding-jwt/) for more details.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete accepted. Workspaces and related data will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteLinkedWorkspacesCall(String authorization, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/security/1.0/linkedWorkspaces/bulk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteLinkedWorkspacesValidateBeforeCall(String authorization, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling deleteLinkedWorkspaces(Async)");
        }

        return deleteLinkedWorkspacesCall(authorization, _callback);

    }

    /**
     * Delete linked Security Workspaces
     * Bulk delete all linked Security Workspaces that match the given request.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps.  e.g. DELETE /bulk?workspaceIds&#x3D;111-222-333,444-555-666 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read [understanding jwt](https://developer.atlassian.com/blog/2015/01/understanding-jwt/) for more details.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete accepted. Workspaces and related data will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public void deleteLinkedWorkspaces(String authorization) throws ApiException {
        deleteLinkedWorkspacesWithHttpInfo(authorization);
    }

    /**
     * Delete linked Security Workspaces
     * Bulk delete all linked Security Workspaces that match the given request.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps.  e.g. DELETE /bulk?workspaceIds&#x3D;111-222-333,444-555-666 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read [understanding jwt](https://developer.atlassian.com/blog/2015/01/understanding-jwt/) for more details.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete accepted. Workspaces and related data will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteLinkedWorkspacesWithHttpInfo(String authorization) throws ApiException {
        okhttp3.Call localVarCall = deleteLinkedWorkspacesValidateBeforeCall(authorization, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete linked Security Workspaces (asynchronously)
     * Bulk delete all linked Security Workspaces that match the given request.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps.  e.g. DELETE /bulk?workspaceIds&#x3D;111-222-333,444-555-666 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read [understanding jwt](https://developer.atlassian.com/blog/2015/01/understanding-jwt/) for more details.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete accepted. Workspaces and related data will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteLinkedWorkspacesAsync(String authorization, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteLinkedWorkspacesValidateBeforeCall(authorization, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteVulnerabilitiesByProperty
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete accepted. Data will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format (e.g. missing at least one Property param).  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteVulnerabilitiesByPropertyCall(String authorization, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/security/1.0/bulkByProperties";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteVulnerabilitiesByPropertyValidateBeforeCall(String authorization, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling deleteVulnerabilitiesByProperty(Async)");
        }

        return deleteVulnerabilitiesByPropertyCall(authorization, _callback);

    }

    /**
     * Delete Vulnerabilities by Property
     * Bulk delete all Vulnerabilities that match the given request.  One or more query params must be supplied to specify Properties to delete by. If more than one Property is provided, data will be deleted that matches ALL of the Properties (e.g. treated as an AND). Read the POST bulk endpoint documentation for more details.  e.g. DELETE /bulkByProperties?accountId&#x3D;account-123&amp;createdBy&#x3D;user-456  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete accepted. Data will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format (e.g. missing at least one Property param).  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public void deleteVulnerabilitiesByProperty(String authorization) throws ApiException {
        deleteVulnerabilitiesByPropertyWithHttpInfo(authorization);
    }

    /**
     * Delete Vulnerabilities by Property
     * Bulk delete all Vulnerabilities that match the given request.  One or more query params must be supplied to specify Properties to delete by. If more than one Property is provided, data will be deleted that matches ALL of the Properties (e.g. treated as an AND). Read the POST bulk endpoint documentation for more details.  e.g. DELETE /bulkByProperties?accountId&#x3D;account-123&amp;createdBy&#x3D;user-456  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete accepted. Data will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format (e.g. missing at least one Property param).  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteVulnerabilitiesByPropertyWithHttpInfo(String authorization) throws ApiException {
        okhttp3.Call localVarCall = deleteVulnerabilitiesByPropertyValidateBeforeCall(authorization, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete Vulnerabilities by Property (asynchronously)
     * Bulk delete all Vulnerabilities that match the given request.  One or more query params must be supplied to specify Properties to delete by. If more than one Property is provided, data will be deleted that matches ALL of the Properties (e.g. treated as an AND). Read the POST bulk endpoint documentation for more details.  e.g. DELETE /bulkByProperties?accountId&#x3D;account-123&amp;createdBy&#x3D;user-456  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete accepted. Data will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format (e.g. missing at least one Property param).  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteVulnerabilitiesByPropertyAsync(String authorization, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteVulnerabilitiesByPropertyValidateBeforeCall(authorization, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteVulnerabilityById
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param vulnerabilityId The ID of the Vulnerability to delete.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete has been accepted. If the data exists, it will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteVulnerabilityByIdCall(String authorization, String vulnerabilityId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/security/1.0/vulnerability/{vulnerabilityId}"
            .replace("{" + "vulnerabilityId" + "}", localVarApiClient.escapeString(vulnerabilityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteVulnerabilityByIdValidateBeforeCall(String authorization, String vulnerabilityId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling deleteVulnerabilityById(Async)");
        }

        // verify the required parameter 'vulnerabilityId' is set
        if (vulnerabilityId == null) {
            throw new ApiException("Missing the required parameter 'vulnerabilityId' when calling deleteVulnerabilityById(Async)");
        }

        return deleteVulnerabilityByIdCall(authorization, vulnerabilityId, _callback);

    }

    /**
     * Delete a Vulnerability by ID
     * Delete the Vulnerability data currently stored for the given ID.  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param vulnerabilityId The ID of the Vulnerability to delete.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete has been accepted. If the data exists, it will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public void deleteVulnerabilityById(String authorization, String vulnerabilityId) throws ApiException {
        deleteVulnerabilityByIdWithHttpInfo(authorization, vulnerabilityId);
    }

    /**
     * Delete a Vulnerability by ID
     * Delete the Vulnerability data currently stored for the given ID.  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param vulnerabilityId The ID of the Vulnerability to delete.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete has been accepted. If the data exists, it will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> deleteVulnerabilityByIdWithHttpInfo(String authorization, String vulnerabilityId) throws ApiException {
        okhttp3.Call localVarCall = deleteVulnerabilityByIdValidateBeforeCall(authorization, vulnerabilityId, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Delete a Vulnerability by ID (asynchronously)
     * Delete the Vulnerability data currently stored for the given ID.  Deletion is performed asynchronously. The GET vulnerability endpoint can be used to confirm that data has been deleted successfully (if needed).  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;DELETE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param vulnerabilityId The ID of the Vulnerability to delete.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Delete has been accepted. If the data exists, it will eventually be removed from Jira.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;DELETE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call deleteVulnerabilityByIdAsync(String authorization, String vulnerabilityId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteVulnerabilityByIdValidateBeforeCall(authorization, vulnerabilityId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for getLinkedWorkspaceById
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param workspaceId The ID of the workspace to fetch.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Security Workspace information stored for the given ID.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given workspace ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLinkedWorkspaceByIdCall(String authorization, String workspaceId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/security/1.0/linkedWorkspaces/{workspaceId}"
            .replace("{" + "workspaceId" + "}", localVarApiClient.escapeString(workspaceId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLinkedWorkspaceByIdValidateBeforeCall(String authorization, String workspaceId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getLinkedWorkspaceById(Async)");
        }

        // verify the required parameter 'workspaceId' is set
        if (workspaceId == null) {
            throw new ApiException("Missing the required parameter 'workspaceId' when calling getLinkedWorkspaceById(Async)");
        }

        return getLinkedWorkspaceByIdCall(authorization, workspaceId, _callback);

    }

    /**
     * Get a linked Security Workspace by ID
     * Retrieve a specific Security Workspace linked to the Jira site for the given workspace ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param workspaceId The ID of the workspace to fetch.  (required)
     * @return SecurityWorkspaceResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Security Workspace information stored for the given ID.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given workspace ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public SecurityWorkspaceResponse getLinkedWorkspaceById(String authorization, String workspaceId) throws ApiException {
        ApiResponse<SecurityWorkspaceResponse> localVarResp = getLinkedWorkspaceByIdWithHttpInfo(authorization, workspaceId);
        return localVarResp.getData();
    }

    /**
     * Get a linked Security Workspace by ID
     * Retrieve a specific Security Workspace linked to the Jira site for the given workspace ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param workspaceId The ID of the workspace to fetch.  (required)
     * @return ApiResponse&lt;SecurityWorkspaceResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Security Workspace information stored for the given ID.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given workspace ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SecurityWorkspaceResponse> getLinkedWorkspaceByIdWithHttpInfo(String authorization, String workspaceId) throws ApiException {
        okhttp3.Call localVarCall = getLinkedWorkspaceByIdValidateBeforeCall(authorization, workspaceId, null);
        Type localVarReturnType = new TypeToken<SecurityWorkspaceResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a linked Security Workspace by ID (asynchronously)
     * Retrieve a specific Security Workspace linked to the Jira site for the given workspace ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param workspaceId The ID of the workspace to fetch.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Security Workspace information stored for the given ID.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given workspace ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLinkedWorkspaceByIdAsync(String authorization, String workspaceId, final ApiCallback<SecurityWorkspaceResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = getLinkedWorkspaceByIdValidateBeforeCall(authorization, workspaceId, _callback);
        Type localVarReturnType = new TypeToken<SecurityWorkspaceResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getLinkedWorkspaces
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of all stored workspace IDs.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given workspace ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLinkedWorkspacesCall(String authorization, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/security/1.0/linkedWorkspaces";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getLinkedWorkspacesValidateBeforeCall(String authorization, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getLinkedWorkspaces(Async)");
        }

        return getLinkedWorkspacesCall(authorization, _callback);

    }

    /**
     * Get linked Security Workspaces
     * Retrieve all Security Workspaces linked with the Jira site.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @return SecurityWorkspaceIds
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of all stored workspace IDs.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given workspace ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public SecurityWorkspaceIds getLinkedWorkspaces(String authorization) throws ApiException {
        ApiResponse<SecurityWorkspaceIds> localVarResp = getLinkedWorkspacesWithHttpInfo(authorization);
        return localVarResp.getData();
    }

    /**
     * Get linked Security Workspaces
     * Retrieve all Security Workspaces linked with the Jira site.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @return ApiResponse&lt;SecurityWorkspaceIds&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of all stored workspace IDs.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given workspace ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SecurityWorkspaceIds> getLinkedWorkspacesWithHttpInfo(String authorization) throws ApiException {
        okhttp3.Call localVarCall = getLinkedWorkspacesValidateBeforeCall(authorization, null);
        Type localVarReturnType = new TypeToken<SecurityWorkspaceIds>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get linked Security Workspaces (asynchronously)
     * Retrieve all Security Workspaces linked with the Jira site.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> A list of all stored workspace IDs.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given workspace ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getLinkedWorkspacesAsync(String authorization, final ApiCallback<SecurityWorkspaceIds> _callback) throws ApiException {

        okhttp3.Call localVarCall = getLinkedWorkspacesValidateBeforeCall(authorization, _callback);
        Type localVarReturnType = new TypeToken<SecurityWorkspaceIds>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getVulnerabilityById
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param vulnerabilityId The ID of the Vulnerability to fetch.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Vulnerability data currently stored for the given ID.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given Vulnerability ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVulnerabilityByIdCall(String authorization, String vulnerabilityId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/rest/security/1.0/vulnerability/{vulnerabilityId}"
            .replace("{" + "vulnerabilityId" + "}", localVarApiClient.escapeString(vulnerabilityId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getVulnerabilityByIdValidateBeforeCall(String authorization, String vulnerabilityId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling getVulnerabilityById(Async)");
        }

        // verify the required parameter 'vulnerabilityId' is set
        if (vulnerabilityId == null) {
            throw new ApiException("Missing the required parameter 'vulnerabilityId' when calling getVulnerabilityById(Async)");
        }

        return getVulnerabilityByIdCall(authorization, vulnerabilityId, _callback);

    }

    /**
     * Get a Vulnerability by ID
     * Retrieve the currently stored Vulnerability data for the given ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param vulnerabilityId The ID of the Vulnerability to fetch.  (required)
     * @return VulnerabilityDetails
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Vulnerability data currently stored for the given ID.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given Vulnerability ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public VulnerabilityDetails getVulnerabilityById(String authorization, String vulnerabilityId) throws ApiException {
        ApiResponse<VulnerabilityDetails> localVarResp = getVulnerabilityByIdWithHttpInfo(authorization, vulnerabilityId);
        return localVarResp.getData();
    }

    /**
     * Get a Vulnerability by ID
     * Retrieve the currently stored Vulnerability data for the given ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param vulnerabilityId The ID of the Vulnerability to fetch.  (required)
     * @return ApiResponse&lt;VulnerabilityDetails&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Vulnerability data currently stored for the given ID.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given Vulnerability ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<VulnerabilityDetails> getVulnerabilityByIdWithHttpInfo(String authorization, String vulnerabilityId) throws ApiException {
        okhttp3.Call localVarCall = getVulnerabilityByIdValidateBeforeCall(authorization, vulnerabilityId, null);
        Type localVarReturnType = new TypeToken<VulnerabilityDetails>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Get a Vulnerability by ID (asynchronously)
     * Retrieve the currently stored Vulnerability data for the given ID.  The result will be what is currently stored, ignoring any pending updates or deletes.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;READ&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param vulnerabilityId The ID of the Vulnerability to fetch.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> The Vulnerability data currently stored for the given ID.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;READ&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 404 </td><td> No data found for the given Vulnerability ID.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call getVulnerabilityByIdAsync(String authorization, String vulnerabilityId, final ApiCallback<VulnerabilityDetails> _callback) throws ApiException {

        okhttp3.Call localVarCall = getVulnerabilityByIdValidateBeforeCall(authorization, vulnerabilityId, _callback);
        Type localVarReturnType = new TypeToken<VulnerabilityDetails>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for submitVulnerabilities
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param submitVulnerabilitiesRequest Vulnerability data to submit.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Submission accepted. Each Vulnerability submitted in a valid format will eventually be available in Jira.  Details of any Vulnerabilities that were submitted but failed submission (due to data format problems, etc.) are available in the response object.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  Note that in the case of an individual Vulnerability having an invalid format (rather than the request as a whole) the response for the request will be a 202 and details of the invalid Vulnerability will be contained in the response object.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;WRITE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 413 </td><td> Data is too large. Submit fewer Vulnerabilities in each payload.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  * X-RateLimit-Remaining - The number of remaining possible requests in current rate limit window. <br>  * X-RateLimit-Reset - The date in ISO 8601 format when the rate limit values will be next reset. <br>  * X-RateLimit-Limit - The maximum possible requests in a window of one minute. <br>  * Retry-After - The number of seconds to wait before making a follow-up request. <br>  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call submitVulnerabilitiesCall(String authorization, SubmitVulnerabilitiesRequest submitVulnerabilitiesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = submitVulnerabilitiesRequest;

        // create path and map variables
        String localVarPath = "/rest/security/1.0/bulk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call submitVulnerabilitiesValidateBeforeCall(String authorization, SubmitVulnerabilitiesRequest submitVulnerabilitiesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling submitVulnerabilities(Async)");
        }

        // verify the required parameter 'submitVulnerabilitiesRequest' is set
        if (submitVulnerabilitiesRequest == null) {
            throw new ApiException("Missing the required parameter 'submitVulnerabilitiesRequest' when calling submitVulnerabilities(Async)");
        }

        return submitVulnerabilitiesCall(authorization, submitVulnerabilitiesRequest, _callback);

    }

    /**
     * Submit Vulnerability data
     * Update / Insert Vulnerability data.  Vulnerabilities are identified by their ID, any existing Vulnerability data with the same ID will be replaced if it exists and the updateSequenceNumber of the existing data is less than the incoming data.  Submissions are performed asynchronously. Most updates are available within a short period of time but may take some time during peak load and/or maintenance times. The GET vulnerability endpoint can be used to confirm that data has been stored successfully (if needed).  In the case of multiple Vulnerabilities being submitted in one request, each is validated individually prior to submission. Details of Vulnerabilities that failed submission (if any) are available in the response object.  A maximum of 1000 vulnerabilities can be submitted in one request.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;WRITE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param submitVulnerabilitiesRequest Vulnerability data to submit.  (required)
     * @return SubmitVulnerabilitiesResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Submission accepted. Each Vulnerability submitted in a valid format will eventually be available in Jira.  Details of any Vulnerabilities that were submitted but failed submission (due to data format problems, etc.) are available in the response object.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  Note that in the case of an individual Vulnerability having an invalid format (rather than the request as a whole) the response for the request will be a 202 and details of the invalid Vulnerability will be contained in the response object.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;WRITE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 413 </td><td> Data is too large. Submit fewer Vulnerabilities in each payload.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  * X-RateLimit-Remaining - The number of remaining possible requests in current rate limit window. <br>  * X-RateLimit-Reset - The date in ISO 8601 format when the rate limit values will be next reset. <br>  * X-RateLimit-Limit - The maximum possible requests in a window of one minute. <br>  * Retry-After - The number of seconds to wait before making a follow-up request. <br>  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public SubmitVulnerabilitiesResponse submitVulnerabilities(String authorization, SubmitVulnerabilitiesRequest submitVulnerabilitiesRequest) throws ApiException {
        ApiResponse<SubmitVulnerabilitiesResponse> localVarResp = submitVulnerabilitiesWithHttpInfo(authorization, submitVulnerabilitiesRequest);
        return localVarResp.getData();
    }

    /**
     * Submit Vulnerability data
     * Update / Insert Vulnerability data.  Vulnerabilities are identified by their ID, any existing Vulnerability data with the same ID will be replaced if it exists and the updateSequenceNumber of the existing data is less than the incoming data.  Submissions are performed asynchronously. Most updates are available within a short period of time but may take some time during peak load and/or maintenance times. The GET vulnerability endpoint can be used to confirm that data has been stored successfully (if needed).  In the case of multiple Vulnerabilities being submitted in one request, each is validated individually prior to submission. Details of Vulnerabilities that failed submission (if any) are available in the response object.  A maximum of 1000 vulnerabilities can be submitted in one request.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;WRITE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param submitVulnerabilitiesRequest Vulnerability data to submit.  (required)
     * @return ApiResponse&lt;SubmitVulnerabilitiesResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Submission accepted. Each Vulnerability submitted in a valid format will eventually be available in Jira.  Details of any Vulnerabilities that were submitted but failed submission (due to data format problems, etc.) are available in the response object.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  Note that in the case of an individual Vulnerability having an invalid format (rather than the request as a whole) the response for the request will be a 202 and details of the invalid Vulnerability will be contained in the response object.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;WRITE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 413 </td><td> Data is too large. Submit fewer Vulnerabilities in each payload.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  * X-RateLimit-Remaining - The number of remaining possible requests in current rate limit window. <br>  * X-RateLimit-Reset - The date in ISO 8601 format when the rate limit values will be next reset. <br>  * X-RateLimit-Limit - The maximum possible requests in a window of one minute. <br>  * Retry-After - The number of seconds to wait before making a follow-up request. <br>  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<SubmitVulnerabilitiesResponse> submitVulnerabilitiesWithHttpInfo(String authorization, SubmitVulnerabilitiesRequest submitVulnerabilitiesRequest) throws ApiException {
        okhttp3.Call localVarCall = submitVulnerabilitiesValidateBeforeCall(authorization, submitVulnerabilitiesRequest, null);
        Type localVarReturnType = new TypeToken<SubmitVulnerabilitiesResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Submit Vulnerability data (asynchronously)
     * Update / Insert Vulnerability data.  Vulnerabilities are identified by their ID, any existing Vulnerability data with the same ID will be replaced if it exists and the updateSequenceNumber of the existing data is less than the incoming data.  Submissions are performed asynchronously. Most updates are available within a short period of time but may take some time during peak load and/or maintenance times. The GET vulnerability endpoint can be used to confirm that data has been stored successfully (if needed).  In the case of multiple Vulnerabilities being submitted in one request, each is validated individually prior to submission. Details of Vulnerabilities that failed submission (if any) are available in the response object.  A maximum of 1000 vulnerabilities can be submitted in one request.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;WRITE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read more about JWT [here](https://developer.atlassian.com/blog/2015/01/understanding-jwt/).  (required)
     * @param submitVulnerabilitiesRequest Vulnerability data to submit.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Submission accepted. Each Vulnerability submitted in a valid format will eventually be available in Jira.  Details of any Vulnerabilities that were submitted but failed submission (due to data format problems, etc.) are available in the response object.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  Note that in the case of an individual Vulnerability having an invalid format (rather than the request as a whole) the response for the request will be a 202 and details of the invalid Vulnerability will be contained in the response object.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;WRITE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 413 </td><td> Data is too large. Submit fewer Vulnerabilities in each payload.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  * X-RateLimit-Remaining - The number of remaining possible requests in current rate limit window. <br>  * X-RateLimit-Reset - The date in ISO 8601 format when the rate limit values will be next reset. <br>  * X-RateLimit-Limit - The maximum possible requests in a window of one minute. <br>  * Retry-After - The number of seconds to wait before making a follow-up request. <br>  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call submitVulnerabilitiesAsync(String authorization, SubmitVulnerabilitiesRequest submitVulnerabilitiesRequest, final ApiCallback<SubmitVulnerabilitiesResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = submitVulnerabilitiesValidateBeforeCall(authorization, submitVulnerabilitiesRequest, _callback);
        Type localVarReturnType = new TypeToken<SubmitVulnerabilitiesResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for submitWorkspaces
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read [understanding jwt](https://developer.atlassian.com/blog/2015/01/understanding-jwt/) for more details.  (required)
     * @param submitSecurityWorkspacesRequest Security Workspace IDs to submit.  (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Submission accepted. Each submitted Security Workspace ID will be linked to Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;WRITE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 413 </td><td> Set of Ids is too large. Submit fewer Ids in each payload.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call submitWorkspacesCall(String authorization, SubmitSecurityWorkspacesRequest submitSecurityWorkspacesRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = submitSecurityWorkspacesRequest;

        // create path and map variables
        String localVarPath = "/rest/security/1.0/linkedWorkspaces/bulk";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        if (authorization != null) {
            localVarHeaderParams.put("Authorization", localVarApiClient.parameterToString(authorization));
        }


        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call submitWorkspacesValidateBeforeCall(String authorization, SubmitSecurityWorkspacesRequest submitSecurityWorkspacesRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'authorization' is set
        if (authorization == null) {
            throw new ApiException("Missing the required parameter 'authorization' when calling submitWorkspaces(Async)");
        }

        // verify the required parameter 'submitSecurityWorkspacesRequest' is set
        if (submitSecurityWorkspacesRequest == null) {
            throw new ApiException("Missing the required parameter 'submitSecurityWorkspacesRequest' when calling submitWorkspaces(Async)");
        }

        return submitWorkspacesCall(authorization, submitSecurityWorkspacesRequest, _callback);

    }

    /**
     * Submit Security Workspaces to link
     * Insert Security Workspace IDs to establish a relationship between them and the Jira site the app is installed on. If a relationship between the workspace ID and Jira already exists then the workspace ID will be ignored and Jira will process the rest of the entries.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;WRITE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read [understanding jwt](https://developer.atlassian.com/blog/2015/01/understanding-jwt/) for more details.  (required)
     * @param submitSecurityWorkspacesRequest Security Workspace IDs to submit.  (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Submission accepted. Each submitted Security Workspace ID will be linked to Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;WRITE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 413 </td><td> Set of Ids is too large. Submit fewer Ids in each payload.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public void submitWorkspaces(String authorization, SubmitSecurityWorkspacesRequest submitSecurityWorkspacesRequest) throws ApiException {
        submitWorkspacesWithHttpInfo(authorization, submitSecurityWorkspacesRequest);
    }

    /**
     * Submit Security Workspaces to link
     * Insert Security Workspace IDs to establish a relationship between them and the Jira site the app is installed on. If a relationship between the workspace ID and Jira already exists then the workspace ID will be ignored and Jira will process the rest of the entries.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;WRITE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read [understanding jwt](https://developer.atlassian.com/blog/2015/01/understanding-jwt/) for more details.  (required)
     * @param submitSecurityWorkspacesRequest Security Workspace IDs to submit.  (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Submission accepted. Each submitted Security Workspace ID will be linked to Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;WRITE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 413 </td><td> Set of Ids is too large. Submit fewer Ids in each payload.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> submitWorkspacesWithHttpInfo(String authorization, SubmitSecurityWorkspacesRequest submitSecurityWorkspacesRequest) throws ApiException {
        okhttp3.Call localVarCall = submitWorkspacesValidateBeforeCall(authorization, submitSecurityWorkspacesRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Submit Security Workspaces to link (asynchronously)
     * Insert Security Workspace IDs to establish a relationship between them and the Jira site the app is installed on. If a relationship between the workspace ID and Jira already exists then the workspace ID will be ignored and Jira will process the rest of the entries.  Only Connect apps that define the &#x60;jiraSecurityInfoProvider&#x60; module can access this resource. This resource requires the &#39;WRITE&#39; scope for Connect apps. 
     * @param authorization All requests must be signed with a Connect JWT token that corresponds to the Provider app installed in Jira.  If the JWT token corresponds to an app that does not define the Security Information module it will be rejected with a 403.  Read [understanding jwt](https://developer.atlassian.com/blog/2015/01/understanding-jwt/) for more details.  (required)
     * @param submitSecurityWorkspacesRequest Security Workspace IDs to submit.  (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table border="1">
       <caption>Response Details</caption>
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 202 </td><td> Submission accepted. Each submitted Security Workspace ID will be linked to Jira.  </td><td>  -  </td></tr>
        <tr><td> 400 </td><td> Request has incorrect format.  </td><td>  -  </td></tr>
        <tr><td> 401 </td><td> Missing a JWT token, or token is invalid.  </td><td>  -  </td></tr>
        <tr><td> 403 </td><td> The JWT token used does not correspond to an app that defines the &#x60;jiraSecurityInfoProvider&#x60; module, or the app does not define the &#39;WRITE&#39; scope.  </td><td>  -  </td></tr>
        <tr><td> 413 </td><td> Set of Ids is too large. Submit fewer Ids in each payload.  </td><td>  -  </td></tr>
        <tr><td> 429 </td><td> API rate limit has been exceeded.  </td><td>  -  </td></tr>
        <tr><td> 503 </td><td> Service is unavailable due to maintenance or other reasons.  </td><td>  -  </td></tr>
        <tr><td> 0 </td><td> An unknown error has occurred.  </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call submitWorkspacesAsync(String authorization, SubmitSecurityWorkspacesRequest submitSecurityWorkspacesRequest, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = submitWorkspacesValidateBeforeCall(authorization, submitSecurityWorkspacesRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
}
